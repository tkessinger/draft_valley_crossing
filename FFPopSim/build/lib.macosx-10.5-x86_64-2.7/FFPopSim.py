# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
C++/Python library for population genetics.

This library offers *two* simulation packages for population genetics: one for
low-dimensional simulations (up to ~15 loci) and one for high-dimensional ones.

Each package is based on a big class that represents a population:

   - ``haploid_lowd`` for low-dimensional populations
   - ``haploid_highd`` for high-dimensional simulations

A simple example routine is the following::

    #####################################
    #   EXAMPLE SCRIPT                  #
    #####################################
    import numpy as np
    import matplotlib.pyplot as plt
    import FFPopSim as h
    
    c = h.haploid_lowd(4)
    c.set_allele_frequencies([0,0.3,0.6,0.9], N=1000) 
    c.evolve(100)
    c.plot_diversity_histogram()
    plt.show()
    #####################################

which evolves a population with 4 loci for 100 generations starting from fixed
allele frequencies, under neutral conditions, and plots the diversity
histogram afterwards.

For more usage examples, please consult the ``tests`` and ``examples`` folders. 

"""


from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _FFPopSim.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_FFPopSim', [dirname(__file__)])
        except ImportError:
            import _FFPopSim
            return _FFPopSim
        if fp is not None:
            try:
                _mod = imp.load_module('_FFPopSim', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _FFPopSim = swig_import_helper()
    del swig_import_helper
else:
    import _FFPopSim
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _FFPopSim.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_FFPopSim.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_FFPopSim.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_FFPopSim.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_FFPopSim.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_FFPopSim.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_FFPopSim.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_FFPopSim.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_FFPopSim.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_FFPopSim.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_FFPopSim.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_FFPopSim.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_FFPopSim.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_FFPopSim.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_FFPopSim.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_FFPopSim.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_FFPopSim.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _FFPopSim.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class _intVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _FFPopSim._intVector_swiginit(self,_FFPopSim.new__intVector(*args))
    __swig_destroy__ = _FFPopSim.delete__intVector
_intVector.iterator = new_instancemethod(_FFPopSim._intVector_iterator,None,_intVector)
_intVector.__nonzero__ = new_instancemethod(_FFPopSim._intVector___nonzero__,None,_intVector)
_intVector.__bool__ = new_instancemethod(_FFPopSim._intVector___bool__,None,_intVector)
_intVector.__len__ = new_instancemethod(_FFPopSim._intVector___len__,None,_intVector)
_intVector.pop = new_instancemethod(_FFPopSim._intVector_pop,None,_intVector)
_intVector.__getslice__ = new_instancemethod(_FFPopSim._intVector___getslice__,None,_intVector)
_intVector.__setslice__ = new_instancemethod(_FFPopSim._intVector___setslice__,None,_intVector)
_intVector.__delslice__ = new_instancemethod(_FFPopSim._intVector___delslice__,None,_intVector)
_intVector.__delitem__ = new_instancemethod(_FFPopSim._intVector___delitem__,None,_intVector)
_intVector.__getitem__ = new_instancemethod(_FFPopSim._intVector___getitem__,None,_intVector)
_intVector.__setitem__ = new_instancemethod(_FFPopSim._intVector___setitem__,None,_intVector)
_intVector.append = new_instancemethod(_FFPopSim._intVector_append,None,_intVector)
_intVector.empty = new_instancemethod(_FFPopSim._intVector_empty,None,_intVector)
_intVector.size = new_instancemethod(_FFPopSim._intVector_size,None,_intVector)
_intVector.clear = new_instancemethod(_FFPopSim._intVector_clear,None,_intVector)
_intVector.swap = new_instancemethod(_FFPopSim._intVector_swap,None,_intVector)
_intVector.get_allocator = new_instancemethod(_FFPopSim._intVector_get_allocator,None,_intVector)
_intVector.begin = new_instancemethod(_FFPopSim._intVector_begin,None,_intVector)
_intVector.end = new_instancemethod(_FFPopSim._intVector_end,None,_intVector)
_intVector.rbegin = new_instancemethod(_FFPopSim._intVector_rbegin,None,_intVector)
_intVector.rend = new_instancemethod(_FFPopSim._intVector_rend,None,_intVector)
_intVector.pop_back = new_instancemethod(_FFPopSim._intVector_pop_back,None,_intVector)
_intVector.erase = new_instancemethod(_FFPopSim._intVector_erase,None,_intVector)
_intVector.push_back = new_instancemethod(_FFPopSim._intVector_push_back,None,_intVector)
_intVector.front = new_instancemethod(_FFPopSim._intVector_front,None,_intVector)
_intVector.back = new_instancemethod(_FFPopSim._intVector_back,None,_intVector)
_intVector.assign = new_instancemethod(_FFPopSim._intVector_assign,None,_intVector)
_intVector.resize = new_instancemethod(_FFPopSim._intVector_resize,None,_intVector)
_intVector.insert = new_instancemethod(_FFPopSim._intVector_insert,None,_intVector)
_intVector.reserve = new_instancemethod(_FFPopSim._intVector_reserve,None,_intVector)
_intVector.capacity = new_instancemethod(_FFPopSim._intVector_capacity,None,_intVector)
_intVector_swigregister = _FFPopSim._intVector_swigregister
_intVector_swigregister(_intVector)

class vector_tree_step(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _FFPopSim.vector_tree_step_swiginit(self,_FFPopSim.new_vector_tree_step(*args))
    __swig_destroy__ = _FFPopSim.delete_vector_tree_step
vector_tree_step.iterator = new_instancemethod(_FFPopSim.vector_tree_step_iterator,None,vector_tree_step)
vector_tree_step.__nonzero__ = new_instancemethod(_FFPopSim.vector_tree_step___nonzero__,None,vector_tree_step)
vector_tree_step.__bool__ = new_instancemethod(_FFPopSim.vector_tree_step___bool__,None,vector_tree_step)
vector_tree_step.__len__ = new_instancemethod(_FFPopSim.vector_tree_step___len__,None,vector_tree_step)
vector_tree_step.pop = new_instancemethod(_FFPopSim.vector_tree_step_pop,None,vector_tree_step)
vector_tree_step.__getslice__ = new_instancemethod(_FFPopSim.vector_tree_step___getslice__,None,vector_tree_step)
vector_tree_step.__setslice__ = new_instancemethod(_FFPopSim.vector_tree_step___setslice__,None,vector_tree_step)
vector_tree_step.__delslice__ = new_instancemethod(_FFPopSim.vector_tree_step___delslice__,None,vector_tree_step)
vector_tree_step.__delitem__ = new_instancemethod(_FFPopSim.vector_tree_step___delitem__,None,vector_tree_step)
vector_tree_step.__getitem__ = new_instancemethod(_FFPopSim.vector_tree_step___getitem__,None,vector_tree_step)
vector_tree_step.__setitem__ = new_instancemethod(_FFPopSim.vector_tree_step___setitem__,None,vector_tree_step)
vector_tree_step.append = new_instancemethod(_FFPopSim.vector_tree_step_append,None,vector_tree_step)
vector_tree_step.empty = new_instancemethod(_FFPopSim.vector_tree_step_empty,None,vector_tree_step)
vector_tree_step.size = new_instancemethod(_FFPopSim.vector_tree_step_size,None,vector_tree_step)
vector_tree_step.clear = new_instancemethod(_FFPopSim.vector_tree_step_clear,None,vector_tree_step)
vector_tree_step.swap = new_instancemethod(_FFPopSim.vector_tree_step_swap,None,vector_tree_step)
vector_tree_step.get_allocator = new_instancemethod(_FFPopSim.vector_tree_step_get_allocator,None,vector_tree_step)
vector_tree_step.begin = new_instancemethod(_FFPopSim.vector_tree_step_begin,None,vector_tree_step)
vector_tree_step.end = new_instancemethod(_FFPopSim.vector_tree_step_end,None,vector_tree_step)
vector_tree_step.rbegin = new_instancemethod(_FFPopSim.vector_tree_step_rbegin,None,vector_tree_step)
vector_tree_step.rend = new_instancemethod(_FFPopSim.vector_tree_step_rend,None,vector_tree_step)
vector_tree_step.pop_back = new_instancemethod(_FFPopSim.vector_tree_step_pop_back,None,vector_tree_step)
vector_tree_step.erase = new_instancemethod(_FFPopSim.vector_tree_step_erase,None,vector_tree_step)
vector_tree_step.push_back = new_instancemethod(_FFPopSim.vector_tree_step_push_back,None,vector_tree_step)
vector_tree_step.front = new_instancemethod(_FFPopSim.vector_tree_step_front,None,vector_tree_step)
vector_tree_step.back = new_instancemethod(_FFPopSim.vector_tree_step_back,None,vector_tree_step)
vector_tree_step.assign = new_instancemethod(_FFPopSim.vector_tree_step_assign,None,vector_tree_step)
vector_tree_step.resize = new_instancemethod(_FFPopSim.vector_tree_step_resize,None,vector_tree_step)
vector_tree_step.insert = new_instancemethod(_FFPopSim.vector_tree_step_insert,None,vector_tree_step)
vector_tree_step.reserve = new_instancemethod(_FFPopSim.vector_tree_step_reserve,None,vector_tree_step)
vector_tree_step.capacity = new_instancemethod(_FFPopSim.vector_tree_step_capacity,None,vector_tree_step)
vector_tree_step_swigregister = _FFPopSim.vector_tree_step_swigregister
vector_tree_step_swigregister(vector_tree_step)

class vector_tree_key(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _FFPopSim.vector_tree_key_swiginit(self,_FFPopSim.new_vector_tree_key(*args))
    __swig_destroy__ = _FFPopSim.delete_vector_tree_key
vector_tree_key.iterator = new_instancemethod(_FFPopSim.vector_tree_key_iterator,None,vector_tree_key)
vector_tree_key.__nonzero__ = new_instancemethod(_FFPopSim.vector_tree_key___nonzero__,None,vector_tree_key)
vector_tree_key.__bool__ = new_instancemethod(_FFPopSim.vector_tree_key___bool__,None,vector_tree_key)
vector_tree_key.__len__ = new_instancemethod(_FFPopSim.vector_tree_key___len__,None,vector_tree_key)
vector_tree_key.pop = new_instancemethod(_FFPopSim.vector_tree_key_pop,None,vector_tree_key)
vector_tree_key.__getslice__ = new_instancemethod(_FFPopSim.vector_tree_key___getslice__,None,vector_tree_key)
vector_tree_key.__setslice__ = new_instancemethod(_FFPopSim.vector_tree_key___setslice__,None,vector_tree_key)
vector_tree_key.__delslice__ = new_instancemethod(_FFPopSim.vector_tree_key___delslice__,None,vector_tree_key)
vector_tree_key.__delitem__ = new_instancemethod(_FFPopSim.vector_tree_key___delitem__,None,vector_tree_key)
vector_tree_key.__getitem__ = new_instancemethod(_FFPopSim.vector_tree_key___getitem__,None,vector_tree_key)
vector_tree_key.__setitem__ = new_instancemethod(_FFPopSim.vector_tree_key___setitem__,None,vector_tree_key)
vector_tree_key.append = new_instancemethod(_FFPopSim.vector_tree_key_append,None,vector_tree_key)
vector_tree_key.empty = new_instancemethod(_FFPopSim.vector_tree_key_empty,None,vector_tree_key)
vector_tree_key.size = new_instancemethod(_FFPopSim.vector_tree_key_size,None,vector_tree_key)
vector_tree_key.clear = new_instancemethod(_FFPopSim.vector_tree_key_clear,None,vector_tree_key)
vector_tree_key.swap = new_instancemethod(_FFPopSim.vector_tree_key_swap,None,vector_tree_key)
vector_tree_key.get_allocator = new_instancemethod(_FFPopSim.vector_tree_key_get_allocator,None,vector_tree_key)
vector_tree_key.begin = new_instancemethod(_FFPopSim.vector_tree_key_begin,None,vector_tree_key)
vector_tree_key.end = new_instancemethod(_FFPopSim.vector_tree_key_end,None,vector_tree_key)
vector_tree_key.rbegin = new_instancemethod(_FFPopSim.vector_tree_key_rbegin,None,vector_tree_key)
vector_tree_key.rend = new_instancemethod(_FFPopSim.vector_tree_key_rend,None,vector_tree_key)
vector_tree_key.pop_back = new_instancemethod(_FFPopSim.vector_tree_key_pop_back,None,vector_tree_key)
vector_tree_key.erase = new_instancemethod(_FFPopSim.vector_tree_key_erase,None,vector_tree_key)
vector_tree_key.push_back = new_instancemethod(_FFPopSim.vector_tree_key_push_back,None,vector_tree_key)
vector_tree_key.front = new_instancemethod(_FFPopSim.vector_tree_key_front,None,vector_tree_key)
vector_tree_key.back = new_instancemethod(_FFPopSim.vector_tree_key_back,None,vector_tree_key)
vector_tree_key.assign = new_instancemethod(_FFPopSim.vector_tree_key_assign,None,vector_tree_key)
vector_tree_key.resize = new_instancemethod(_FFPopSim.vector_tree_key_resize,None,vector_tree_key)
vector_tree_key.insert = new_instancemethod(_FFPopSim.vector_tree_key_insert,None,vector_tree_key)
vector_tree_key.reserve = new_instancemethod(_FFPopSim.vector_tree_key_reserve,None,vector_tree_key)
vector_tree_key.capacity = new_instancemethod(_FFPopSim.vector_tree_key_capacity,None,vector_tree_key)
vector_tree_key_swigregister = _FFPopSim.vector_tree_key_swigregister
vector_tree_key_swigregister(vector_tree_key)

class list_tree_key(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _FFPopSim.list_tree_key_swiginit(self,_FFPopSim.new_list_tree_key(*args))
    __swig_destroy__ = _FFPopSim.delete_list_tree_key
list_tree_key.iterator = new_instancemethod(_FFPopSim.list_tree_key_iterator,None,list_tree_key)
list_tree_key.__nonzero__ = new_instancemethod(_FFPopSim.list_tree_key___nonzero__,None,list_tree_key)
list_tree_key.__bool__ = new_instancemethod(_FFPopSim.list_tree_key___bool__,None,list_tree_key)
list_tree_key.__len__ = new_instancemethod(_FFPopSim.list_tree_key___len__,None,list_tree_key)
list_tree_key.pop = new_instancemethod(_FFPopSim.list_tree_key_pop,None,list_tree_key)
list_tree_key.__getslice__ = new_instancemethod(_FFPopSim.list_tree_key___getslice__,None,list_tree_key)
list_tree_key.__setslice__ = new_instancemethod(_FFPopSim.list_tree_key___setslice__,None,list_tree_key)
list_tree_key.__delslice__ = new_instancemethod(_FFPopSim.list_tree_key___delslice__,None,list_tree_key)
list_tree_key.__delitem__ = new_instancemethod(_FFPopSim.list_tree_key___delitem__,None,list_tree_key)
list_tree_key.__getitem__ = new_instancemethod(_FFPopSim.list_tree_key___getitem__,None,list_tree_key)
list_tree_key.__setitem__ = new_instancemethod(_FFPopSim.list_tree_key___setitem__,None,list_tree_key)
list_tree_key.append = new_instancemethod(_FFPopSim.list_tree_key_append,None,list_tree_key)
list_tree_key.empty = new_instancemethod(_FFPopSim.list_tree_key_empty,None,list_tree_key)
list_tree_key.size = new_instancemethod(_FFPopSim.list_tree_key_size,None,list_tree_key)
list_tree_key.clear = new_instancemethod(_FFPopSim.list_tree_key_clear,None,list_tree_key)
list_tree_key.swap = new_instancemethod(_FFPopSim.list_tree_key_swap,None,list_tree_key)
list_tree_key.get_allocator = new_instancemethod(_FFPopSim.list_tree_key_get_allocator,None,list_tree_key)
list_tree_key.begin = new_instancemethod(_FFPopSim.list_tree_key_begin,None,list_tree_key)
list_tree_key.end = new_instancemethod(_FFPopSim.list_tree_key_end,None,list_tree_key)
list_tree_key.rbegin = new_instancemethod(_FFPopSim.list_tree_key_rbegin,None,list_tree_key)
list_tree_key.rend = new_instancemethod(_FFPopSim.list_tree_key_rend,None,list_tree_key)
list_tree_key.pop_back = new_instancemethod(_FFPopSim.list_tree_key_pop_back,None,list_tree_key)
list_tree_key.erase = new_instancemethod(_FFPopSim.list_tree_key_erase,None,list_tree_key)
list_tree_key.push_back = new_instancemethod(_FFPopSim.list_tree_key_push_back,None,list_tree_key)
list_tree_key.front = new_instancemethod(_FFPopSim.list_tree_key_front,None,list_tree_key)
list_tree_key.back = new_instancemethod(_FFPopSim.list_tree_key_back,None,list_tree_key)
list_tree_key.assign = new_instancemethod(_FFPopSim.list_tree_key_assign,None,list_tree_key)
list_tree_key.resize = new_instancemethod(_FFPopSim.list_tree_key_resize,None,list_tree_key)
list_tree_key.insert = new_instancemethod(_FFPopSim.list_tree_key_insert,None,list_tree_key)
list_tree_key.pop_front = new_instancemethod(_FFPopSim.list_tree_key_pop_front,None,list_tree_key)
list_tree_key.push_front = new_instancemethod(_FFPopSim.list_tree_key_push_front,None,list_tree_key)
list_tree_key.reverse = new_instancemethod(_FFPopSim.list_tree_key_reverse,None,list_tree_key)
list_tree_key_swigregister = _FFPopSim.list_tree_key_swigregister
list_tree_key_swigregister(list_tree_key)

class map_key_edge(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __init__(self, *args): 
        _FFPopSim.map_key_edge_swiginit(self,_FFPopSim.new_map_key_edge(*args))
    __swig_destroy__ = _FFPopSim.delete_map_key_edge
map_key_edge.iterator = new_instancemethod(_FFPopSim.map_key_edge_iterator,None,map_key_edge)
map_key_edge.__nonzero__ = new_instancemethod(_FFPopSim.map_key_edge___nonzero__,None,map_key_edge)
map_key_edge.__bool__ = new_instancemethod(_FFPopSim.map_key_edge___bool__,None,map_key_edge)
map_key_edge.__len__ = new_instancemethod(_FFPopSim.map_key_edge___len__,None,map_key_edge)
map_key_edge.__getitem__ = new_instancemethod(_FFPopSim.map_key_edge___getitem__,None,map_key_edge)
map_key_edge.__delitem__ = new_instancemethod(_FFPopSim.map_key_edge___delitem__,None,map_key_edge)
map_key_edge.has_key = new_instancemethod(_FFPopSim.map_key_edge_has_key,None,map_key_edge)
map_key_edge.keys = new_instancemethod(_FFPopSim.map_key_edge_keys,None,map_key_edge)
map_key_edge.values = new_instancemethod(_FFPopSim.map_key_edge_values,None,map_key_edge)
map_key_edge.items = new_instancemethod(_FFPopSim.map_key_edge_items,None,map_key_edge)
map_key_edge.__contains__ = new_instancemethod(_FFPopSim.map_key_edge___contains__,None,map_key_edge)
map_key_edge.key_iterator = new_instancemethod(_FFPopSim.map_key_edge_key_iterator,None,map_key_edge)
map_key_edge.value_iterator = new_instancemethod(_FFPopSim.map_key_edge_value_iterator,None,map_key_edge)
map_key_edge.__setitem__ = new_instancemethod(_FFPopSim.map_key_edge___setitem__,None,map_key_edge)
map_key_edge.asdict = new_instancemethod(_FFPopSim.map_key_edge_asdict,None,map_key_edge)
map_key_edge.empty = new_instancemethod(_FFPopSim.map_key_edge_empty,None,map_key_edge)
map_key_edge.size = new_instancemethod(_FFPopSim.map_key_edge_size,None,map_key_edge)
map_key_edge.clear = new_instancemethod(_FFPopSim.map_key_edge_clear,None,map_key_edge)
map_key_edge.swap = new_instancemethod(_FFPopSim.map_key_edge_swap,None,map_key_edge)
map_key_edge.get_allocator = new_instancemethod(_FFPopSim.map_key_edge_get_allocator,None,map_key_edge)
map_key_edge.begin = new_instancemethod(_FFPopSim.map_key_edge_begin,None,map_key_edge)
map_key_edge.end = new_instancemethod(_FFPopSim.map_key_edge_end,None,map_key_edge)
map_key_edge.rbegin = new_instancemethod(_FFPopSim.map_key_edge_rbegin,None,map_key_edge)
map_key_edge.rend = new_instancemethod(_FFPopSim.map_key_edge_rend,None,map_key_edge)
map_key_edge.count = new_instancemethod(_FFPopSim.map_key_edge_count,None,map_key_edge)
map_key_edge.erase = new_instancemethod(_FFPopSim.map_key_edge_erase,None,map_key_edge)
map_key_edge.find = new_instancemethod(_FFPopSim.map_key_edge_find,None,map_key_edge)
map_key_edge.lower_bound = new_instancemethod(_FFPopSim.map_key_edge_lower_bound,None,map_key_edge)
map_key_edge.upper_bound = new_instancemethod(_FFPopSim.map_key_edge_upper_bound,None,map_key_edge)
map_key_edge_swigregister = _FFPopSim.map_key_edge_swigregister
map_key_edge_swigregister(map_key_edge)

class map_key_node(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __init__(self, *args): 
        _FFPopSim.map_key_node_swiginit(self,_FFPopSim.new_map_key_node(*args))
    __swig_destroy__ = _FFPopSim.delete_map_key_node
map_key_node.iterator = new_instancemethod(_FFPopSim.map_key_node_iterator,None,map_key_node)
map_key_node.__nonzero__ = new_instancemethod(_FFPopSim.map_key_node___nonzero__,None,map_key_node)
map_key_node.__bool__ = new_instancemethod(_FFPopSim.map_key_node___bool__,None,map_key_node)
map_key_node.__len__ = new_instancemethod(_FFPopSim.map_key_node___len__,None,map_key_node)
map_key_node.__getitem__ = new_instancemethod(_FFPopSim.map_key_node___getitem__,None,map_key_node)
map_key_node.__delitem__ = new_instancemethod(_FFPopSim.map_key_node___delitem__,None,map_key_node)
map_key_node.has_key = new_instancemethod(_FFPopSim.map_key_node_has_key,None,map_key_node)
map_key_node.keys = new_instancemethod(_FFPopSim.map_key_node_keys,None,map_key_node)
map_key_node.values = new_instancemethod(_FFPopSim.map_key_node_values,None,map_key_node)
map_key_node.items = new_instancemethod(_FFPopSim.map_key_node_items,None,map_key_node)
map_key_node.__contains__ = new_instancemethod(_FFPopSim.map_key_node___contains__,None,map_key_node)
map_key_node.key_iterator = new_instancemethod(_FFPopSim.map_key_node_key_iterator,None,map_key_node)
map_key_node.value_iterator = new_instancemethod(_FFPopSim.map_key_node_value_iterator,None,map_key_node)
map_key_node.__setitem__ = new_instancemethod(_FFPopSim.map_key_node___setitem__,None,map_key_node)
map_key_node.asdict = new_instancemethod(_FFPopSim.map_key_node_asdict,None,map_key_node)
map_key_node.empty = new_instancemethod(_FFPopSim.map_key_node_empty,None,map_key_node)
map_key_node.size = new_instancemethod(_FFPopSim.map_key_node_size,None,map_key_node)
map_key_node.clear = new_instancemethod(_FFPopSim.map_key_node_clear,None,map_key_node)
map_key_node.swap = new_instancemethod(_FFPopSim.map_key_node_swap,None,map_key_node)
map_key_node.get_allocator = new_instancemethod(_FFPopSim.map_key_node_get_allocator,None,map_key_node)
map_key_node.begin = new_instancemethod(_FFPopSim.map_key_node_begin,None,map_key_node)
map_key_node.end = new_instancemethod(_FFPopSim.map_key_node_end,None,map_key_node)
map_key_node.rbegin = new_instancemethod(_FFPopSim.map_key_node_rbegin,None,map_key_node)
map_key_node.rend = new_instancemethod(_FFPopSim.map_key_node_rend,None,map_key_node)
map_key_node.count = new_instancemethod(_FFPopSim.map_key_node_count,None,map_key_node)
map_key_node.erase = new_instancemethod(_FFPopSim.map_key_node_erase,None,map_key_node)
map_key_node.find = new_instancemethod(_FFPopSim.map_key_node_find,None,map_key_node)
map_key_node.lower_bound = new_instancemethod(_FFPopSim.map_key_node_lower_bound,None,map_key_node)
map_key_node.upper_bound = new_instancemethod(_FFPopSim.map_key_node_upper_bound,None,map_key_node)
map_key_node_swigregister = _FFPopSim.map_key_node_swigregister
map_key_node_swigregister(map_key_node)

class vector_polymorphism(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self): return self.iterator()
    def __init__(self, *args): 
        _FFPopSim.vector_polymorphism_swiginit(self,_FFPopSim.new_vector_polymorphism(*args))
    __swig_destroy__ = _FFPopSim.delete_vector_polymorphism
vector_polymorphism.iterator = new_instancemethod(_FFPopSim.vector_polymorphism_iterator,None,vector_polymorphism)
vector_polymorphism.__nonzero__ = new_instancemethod(_FFPopSim.vector_polymorphism___nonzero__,None,vector_polymorphism)
vector_polymorphism.__bool__ = new_instancemethod(_FFPopSim.vector_polymorphism___bool__,None,vector_polymorphism)
vector_polymorphism.__len__ = new_instancemethod(_FFPopSim.vector_polymorphism___len__,None,vector_polymorphism)
vector_polymorphism.pop = new_instancemethod(_FFPopSim.vector_polymorphism_pop,None,vector_polymorphism)
vector_polymorphism.__getslice__ = new_instancemethod(_FFPopSim.vector_polymorphism___getslice__,None,vector_polymorphism)
vector_polymorphism.__setslice__ = new_instancemethod(_FFPopSim.vector_polymorphism___setslice__,None,vector_polymorphism)
vector_polymorphism.__delslice__ = new_instancemethod(_FFPopSim.vector_polymorphism___delslice__,None,vector_polymorphism)
vector_polymorphism.__delitem__ = new_instancemethod(_FFPopSim.vector_polymorphism___delitem__,None,vector_polymorphism)
vector_polymorphism.__getitem__ = new_instancemethod(_FFPopSim.vector_polymorphism___getitem__,None,vector_polymorphism)
vector_polymorphism.__setitem__ = new_instancemethod(_FFPopSim.vector_polymorphism___setitem__,None,vector_polymorphism)
vector_polymorphism.append = new_instancemethod(_FFPopSim.vector_polymorphism_append,None,vector_polymorphism)
vector_polymorphism.empty = new_instancemethod(_FFPopSim.vector_polymorphism_empty,None,vector_polymorphism)
vector_polymorphism.size = new_instancemethod(_FFPopSim.vector_polymorphism_size,None,vector_polymorphism)
vector_polymorphism.clear = new_instancemethod(_FFPopSim.vector_polymorphism_clear,None,vector_polymorphism)
vector_polymorphism.swap = new_instancemethod(_FFPopSim.vector_polymorphism_swap,None,vector_polymorphism)
vector_polymorphism.get_allocator = new_instancemethod(_FFPopSim.vector_polymorphism_get_allocator,None,vector_polymorphism)
vector_polymorphism.begin = new_instancemethod(_FFPopSim.vector_polymorphism_begin,None,vector_polymorphism)
vector_polymorphism.end = new_instancemethod(_FFPopSim.vector_polymorphism_end,None,vector_polymorphism)
vector_polymorphism.rbegin = new_instancemethod(_FFPopSim.vector_polymorphism_rbegin,None,vector_polymorphism)
vector_polymorphism.rend = new_instancemethod(_FFPopSim.vector_polymorphism_rend,None,vector_polymorphism)
vector_polymorphism.pop_back = new_instancemethod(_FFPopSim.vector_polymorphism_pop_back,None,vector_polymorphism)
vector_polymorphism.erase = new_instancemethod(_FFPopSim.vector_polymorphism_erase,None,vector_polymorphism)
vector_polymorphism.push_back = new_instancemethod(_FFPopSim.vector_polymorphism_push_back,None,vector_polymorphism)
vector_polymorphism.front = new_instancemethod(_FFPopSim.vector_polymorphism_front,None,vector_polymorphism)
vector_polymorphism.back = new_instancemethod(_FFPopSim.vector_polymorphism_back,None,vector_polymorphism)
vector_polymorphism.assign = new_instancemethod(_FFPopSim.vector_polymorphism_assign,None,vector_polymorphism)
vector_polymorphism.resize = new_instancemethod(_FFPopSim.vector_polymorphism_resize,None,vector_polymorphism)
vector_polymorphism.insert = new_instancemethod(_FFPopSim.vector_polymorphism_insert,None,vector_polymorphism)
vector_polymorphism.reserve = new_instancemethod(_FFPopSim.vector_polymorphism_reserve,None,vector_polymorphism)
vector_polymorphism.capacity = new_instancemethod(_FFPopSim.vector_polymorphism_capacity,None,vector_polymorphism)
vector_polymorphism_swigregister = _FFPopSim.vector_polymorphism_swigregister
vector_polymorphism_swigregister(vector_polymorphism)

LICENSE = '''FFPopSim is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. FFPopSim is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with FFPopSim. If not, see <http://www.gnu.org/licenses/>.'''

import numpy as _np

FREE_RECOMBINATION = _FFPopSim.FREE_RECOMBINATION
CROSSOVERS = _FFPopSim.CROSSOVERS
SINGLE_CROSSOVER = _FFPopSim.SINGLE_CROSSOVER
class index_value_pair(object):
    """Pair of an index and a value"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    index = _swig_property(_FFPopSim.index_value_pair_index_get, _FFPopSim.index_value_pair_index_set)
    val = _swig_property(_FFPopSim.index_value_pair_val_get, _FFPopSim.index_value_pair_val_set)
    def __init__(self, index_in=0, val_in=0): 
        """Pair of an index and a value"""
        _FFPopSim.index_value_pair_swiginit(self,_FFPopSim.new_index_value_pair(index_in, val_in))
    def __str__(self):
        """__str__(index_value_pair self) -> char const *"""
        return _FFPopSim.index_value_pair___str__(self)

    def __repr__(self):
        """__repr__(index_value_pair self) -> char const *"""
        return _FFPopSim.index_value_pair___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_index_value_pair
index_value_pair.__str__ = new_instancemethod(_FFPopSim.index_value_pair___str__,None,index_value_pair)
index_value_pair.__repr__ = new_instancemethod(_FFPopSim.index_value_pair___repr__,None,index_value_pair)
index_value_pair_swigregister = _FFPopSim.index_value_pair_swigregister
index_value_pair_swigregister(index_value_pair)

class genotype_value_pair(object):
    """Pair of a genotype and a value"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    genotype = _swig_property(_FFPopSim.genotype_value_pair_genotype_get, _FFPopSim.genotype_value_pair_genotype_set)
    val = _swig_property(_FFPopSim.genotype_value_pair_val_get, _FFPopSim.genotype_value_pair_val_set)
    def __init__(self, *args, **kwargs): 
        """Pair of a genotype and a value"""
        _FFPopSim.genotype_value_pair_swiginit(self,_FFPopSim.new_genotype_value_pair(*args, **kwargs))
    def __str__(self):
        """__str__(genotype_value_pair self) -> char const *"""
        return _FFPopSim.genotype_value_pair___str__(self)

    def __repr__(self):
        """__repr__(genotype_value_pair self) -> char const *"""
        return _FFPopSim.genotype_value_pair___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_genotype_value_pair
genotype_value_pair.__str__ = new_instancemethod(_FFPopSim.genotype_value_pair___str__,None,genotype_value_pair)
genotype_value_pair.__repr__ = new_instancemethod(_FFPopSim.genotype_value_pair___repr__,None,genotype_value_pair)
genotype_value_pair_swigregister = _FFPopSim.genotype_value_pair_swigregister
genotype_value_pair_swigregister(genotype_value_pair)

class stat(object):
    """Mean and variance of a statistical distribution"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    mean = _swig_property(_FFPopSim.stat_mean_get, _FFPopSim.stat_mean_set)
    variance = _swig_property(_FFPopSim.stat_variance_get, _FFPopSim.stat_variance_set)
    def __init__(self, mean_in=0, variance_in=0): 
        """Mean and variance of a statistical distribution"""
        _FFPopSim.stat_swiginit(self,_FFPopSim.new_stat(mean_in, variance_in))
    def __str__(self):
        """__str__(stat self) -> char const *"""
        return _FFPopSim.stat___str__(self)

    def __repr__(self):
        """__repr__(stat self) -> char const *"""
        return _FFPopSim.stat___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_stat
stat.__str__ = new_instancemethod(_FFPopSim.stat___str__,None,stat)
stat.__repr__ = new_instancemethod(_FFPopSim.stat___repr__,None,stat)
stat_swigregister = _FFPopSim.stat_swigregister
stat_swigregister(stat)

def binarify(gt, L=0):
    '''Transform an integer into a binary sequence on the L hypercube.

    Parameters:
       - gt: integer representing a genotype
       - L: number of dimensions of the hypercube

    Returns:
       - genotype: bool vector representing the same genotype

    **Examples**:

    .. sourcecode:: ipython

       In [1]: binarify(3, 5)
       Out[1]: array([False, False, False,  True,  True], dtype=bool)

       In [2]: FFPopSim.binarify(0b11, 5)
       Out[2]: array([False, False, False,  True,  True], dtype=bool)       
    '''
    if not L:
        L=1
        while gt > ((1<<L) - 1):
            L += 1
    return _np.array(map(lambda l: bool(gt&(1<<(L-l-1))),range(L)))


def integerify(b):
    '''Transform a binary sequence on the HC into an integer.

    Parameters:
       - b: bool vector representing a genotype

    Returns:
       - gt: integer representing the same genotype

    **Examples**:

    .. sourcecode:: ipython

       In [1]: integerify([False, True, True])
       Out[1]: 3
    '''
    L = len(b)
    a = [(1<<(L-l-1)) for l in xrange(L)]
    return _np.dot(b,a)

HC_MEMERR = _FFPopSim.HC_MEMERR
HC_BADARG = _FFPopSim.HC_BADARG
HC_VERBOSE = _FFPopSim.HC_VERBOSE
HC_FUNC = _FFPopSim.HC_FUNC
HC_COEFF = _FFPopSim.HC_COEFF
HC_FUNC_EQ_COEFF = _FFPopSim.HC_FUNC_EQ_COEFF
HG_VERBOSE = _FFPopSim.HG_VERBOSE
HG_LONGTIMEGEN = _FFPopSim.HG_LONGTIMEGEN
HG_CONTINUOUS = _FFPopSim.HG_CONTINUOUS
HG_NOTHING = _FFPopSim.HG_NOTHING
HG_EXTINCT = _FFPopSim.HG_EXTINCT
HG_BADARG = _FFPopSim.HG_BADARG
HG_MEMERR = _FFPopSim.HG_MEMERR
class haploid_lowd(object):
    """
    Class for low-dimensional population genetics (short genomes ~20 loci).

    The class offers a number of functions, but an example will explain the basic idea::

        #####################################
        #   EXAMPLE SCRIPT                  #
        #####################################
        import numpy as np
        import matplotlib.pyplot as plt
        import FFPopSim as h
        
        c = h.haploid_lowd(5)               # 5 loci

        # initialize with 300 individuals with genotype 00000,
        # and 700 with genotype 00010
        c.set_genotypes([0, 2], [300, 700])
     
        # set an additive fitness landscape with these coefficients
        c.set_fitness_additive([0.02,0.03,0.04,0.02, -0.03])
        # Note: we are in the -/+ basis, so
        #        F[10000] - F[00000] = 2 * 0.02 
        # Hence the coefficients are half of the effect of mutation on fitness 

        c.evolve(100)                       # evolve for 100 generations
        c.plot_diversity_histogram()
        plt.show()
        #####################################

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, L=1, rng_seed=0): 
        """
        Construct a low-dimensional population with certain parameters.

        Parameters:
            - L : number of loci (at least 1)
            - rng_seed : seed for the random number generator    

        """
        _FFPopSim.haploid_lowd_swiginit(self,_FFPopSim.new_haploid_lowd(L, rng_seed))
    __swig_destroy__ = _FFPopSim.delete_haploid_lowd
    carrying_capacity = _swig_property(_FFPopSim.haploid_lowd_carrying_capacity_get, _FFPopSim.haploid_lowd_carrying_capacity_set)
    outcrossing_rate = _swig_property(_FFPopSim.haploid_lowd_outcrossing_rate_get, _FFPopSim.haploid_lowd_outcrossing_rate_set)
    circular = _swig_property(_FFPopSim.haploid_lowd_circular_get, _FFPopSim.haploid_lowd_circular_set)
    def _get_mutation_rate(self, *args, **kwargs):
        """_get_mutation_rate(haploid_lowd self, int locus, int direction) -> double"""
        return _FFPopSim.haploid_lowd__get_mutation_rate(self, *args, **kwargs)

    def _get_recombination_model(self):
        """
        Model of recombination to use

        Available values:

           - FFPopSim.FREE_RECOMBINATION: free shuffling between parents
           - FFPopSim.CROSSOVERS: block recombination with crossover probability
           - FFPopSim.SINGLE_CROSSOVER: block recombination with crossover probability

        """
        return _FFPopSim.haploid_lowd__get_recombination_model(self)

    def get_recombination_rate(self, *args, **kwargs):
        """
        Get the recombination rate between the specified locus and the following one.

        """
        if len(args) and (args[0] >= self.L - 1):
            raise ValueError("Expecting a locus from 0 to L - 2.")


        return _FFPopSim.haploid_lowd_get_recombination_rate(self, *args, **kwargs)

    def set_allele_frequencies(self, *args, **kwargs):
        """
        Initialize the population in linkage equilibrium with specified allele frequencies.

        Parameters:
           - frequencies: an array of length L with all allele frequencies
           - N: set the population size and, if still unset, the carrying
             capacity to this value

        .. note:: the population size is only used for resampling and has therefore
                  no effect on the speed of the simulation.

        """
        if len(args) and (len(args[0]) != self.L):
            raise ValueError('The input array of allele frequencies has the wrong length.')


        val = _FFPopSim.haploid_lowd_set_allele_frequencies(self, *args, **kwargs)
        return None


        return val

    def set_wildtype(self, *args, **kwargs):
        """
        Initialize population of N individuals with the - allele at all loci (wildtype)

        Parameters:
           - N: the number of individuals

        .. note:: the carrying capacity is set to the same value if still unset.

        """
        val = _FFPopSim.haploid_lowd_set_wildtype(self, *args, **kwargs)
        return None


        return val

    def _set_recombination_model(self, *args, **kwargs):
        """_set_recombination_model(haploid_lowd self, int rec_model) -> int"""
        return _FFPopSim.haploid_lowd__set_recombination_model(self, *args, **kwargs)

    def _set_recombination_rates(self, *args, **kwargs):
        """_set_recombination_rates(haploid_lowd self, double * rec_rates, int rec_model=-1) -> int"""
        return _FFPopSim.haploid_lowd__set_recombination_rates(self, *args, **kwargs)

    def evolve(self, gen=1):
        """
        Evolve for some generations

        Parameters:
            - gen: number of generations to evolve the population, defaults to one

        """
        val = _FFPopSim.haploid_lowd_evolve(self, gen)
        return None


        return val

    def evolve_norec(self, gen=1):
        """
        Evolve for some generations without recombination

        Parameters:
            - gen: number of generations to evolve the population

        """
        val = _FFPopSim.haploid_lowd_evolve_norec(self, gen)
        return None


        return val

    def evolve_deterministic(self, gen=1):
        """
        Evolve for some generations deterministically (skips the resampling)

        Parameters:
            - gen: number of generations to evolve the population

        """
        val = _FFPopSim.haploid_lowd_evolve_deterministic(self, gen)
        return None


        return val

    def get_genotype_frequency(self, *args, **kwargs):
        """
        Get the frequency of a genotype

        Parameters:
            - genotype: genotype, whose the frequency is to be returned

        Returns:
            - the frequency of the genotype

        """
        if len(args) and (args[0] >= (1<<self.L)):
            raise ValueError("Expecting an individual from 0 to 2^L - 1.")


        return _FFPopSim.haploid_lowd_get_genotype_frequency(self, *args, **kwargs)

    def get_allele_frequency(self, *args, **kwargs):
        """
        Get the frequency of the + allele

        Parameters:
            - locus: locus, at which the frequency of the + allele is to be computed

        Returns:
            - the frequency of the + allele, :math:`\nu_i := \frac{1 + \left<s_i\right>}{2}`, where :math:`s_i \in \{-1, 1\}`.

        """
        if len(args) and (args[0] >= (self.L)):
            raise ValueError("Expecting a locus from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_allele_frequency(self, *args, **kwargs)

    def get_pair_frequency(self, *args, **kwargs):
        """
        Get the frequency of genotypes with the + allele at both loci.

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the joint frequency of the + alleles

        """
        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_pair_frequency(self, *args, **kwargs)

    def get_chi(self, *args, **kwargs):
        """
        Get chi of an allele in the -/+ basis

        Parameters:
            - locus: locus whose chi is to be computed

        Returns:
            - the chi of that allele, :math:`\chi_i := \left<s_i\right>`, where :math:`s_i \in \{-1, 1\}`.

        """
        if len(args) and (args[0] >= (self.L)):
            raise ValueError("Expecting a locus from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_chi(self, *args, **kwargs)

    def get_chi2(self, *args, **kwargs):
        """
        Get :math:`\chi_{ij}`

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`\chi_{ij} := \left<s_i s_j\right> - \chi_i \cdot \chi_j`.

        """
        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_chi2(self, *args, **kwargs)

    def get_LD(self, *args, **kwargs):
        """
        Get linkage disequilibrium

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`D_{ij} := 1 / 4 \left[\left<s_i s_j\right> - \chi_i \cdot \chi_j\right]`.

        """
        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_LD(self, *args, **kwargs)

    def get_moment(self, *args, **kwargs):
        """
        Get moment of two alleles in the -/+ basis

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the second moment, i.e. :math:`\left<s_i s_j\right>`, where :math:`s_i, s_j \in \{-1, 1\}`.

        """
        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_moment(self, *args, **kwargs)

    def genotype_entropy(self):
        """
        Get the genotype entropy of the population

        .. note:: the genotype entropy is defined as :math:`-\sum_{i=0}^{2^L} p_i \log p_i`.

        """
        return _FFPopSim.haploid_lowd_genotype_entropy(self)

    def allele_entropy(self):
        """
        get the allele entropy of the population

        .. note:: the allele entropy is defined as :math:`-\sum_{i=0}^{L} \left[\nu_i\log \nu_i + (1-\nu_i)\log(1-\nu_i)\right]`.

        """
        return _FFPopSim.haploid_lowd_allele_entropy(self)

    def get_fitness(self, *args, **kwargs):
        """
        Get fitness values of a genotype

        Parameters:
            - genotype: genotype whose fitness is to be calculated. This can either be an integer or in binary format, e.g. 5 = 0b101 

        Returns:
            - the fitness of that genotype.

        """
        if len(args) and (args[0] >= (1<<self.L)):
            raise ValueError("Expecting an individual between 0 and 2^L - 1.")


        return _FFPopSim.haploid_lowd_get_fitness(self, *args, **kwargs)

    def get_fitness_statistics(self):
        """get_fitness_statistics(haploid_lowd self) -> stat"""
        return _FFPopSim.haploid_lowd_get_fitness_statistics(self)

    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.haploid_lowd___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.haploid_lowd___repr__(self)

    def copy(self, rng_seed=0):
        '''Copy population into new instance.
        
        Parameters:
           - rng_seed: random number to initialize the new population
        '''
        pop = haploid_lowd(self.L, rng_seed=rng_seed)

        
        if self.recombination_model not in ['FREE_RECOMBINATION']:
            pop.set_recombination_rates(self.get_recombination_rates(), self.recombination_model)
        tmp = self.get_mutation_rates()
        if _np.isscalar(tmp) or tmp.ndim < 2:
            pop.set_mutation_rates(tmp)
        else:
            pop.set_mutation_rates(*tmp)
        pop.circular = self.circular
        pop.outcrossing_rate = self.outcrossing_rate

        
        pop.set_fitness_function(range(1<<self.L), self.get_fitnesses())

        
        pop.carrying_capacity = self.carrying_capacity
        pop.set_genotypes(range(1<<self.L), self.get_genotype_frequencies() * self.N)

        
        pop.generation = self.generation
        
        return pop

    L = _swig_property(_FFPopSim.haploid_lowd_L_get)
    number_of_loci = _swig_property(_FFPopSim.haploid_lowd_number_of_loci_get)
    N = _swig_property(_FFPopSim.haploid_lowd_N_get)
    population_size = _swig_property(_FFPopSim.haploid_lowd_population_size_get)
    generation = _swig_property(_FFPopSim.haploid_lowd_generation_get, _FFPopSim.haploid_lowd_generation_set)
    recombination_model = property(_get_recombination_model, _set_recombination_model)

    def status(self):
        '''Print a status list of the population parameters'''
        parameters = (('number of loci', 'L'),
                      ('circular', 'circular'),
                      ('population size', 'N'),
                      ('carrying capacity', 'carrying_capacity'),
                      ('generation', 'generation'),
                      ('outcrossing rate', 'outcrossing_rate'),
                      ('recombination model', 'recombination_model'),
                     )
        lenmax = max(map(lambda x: len(x[0]), parameters))

        for (strin, name) in parameters:
            par = getattr(self, name)
            
            
            if strin == 'recombination model':
                if par == 0:
                    par = 'FREE_RECOMBINATION'
                elif par == 1:
                    par = 'SINGLE_CROSSOVER'
                else:
                    par = 'CROSSOVERS'
            print ('{:<'+str(lenmax + 2)+'s}').format(strin)+'\t'+str(par)

    def _set_genotypes(self, *args, **kwargs):
        """_set_genotypes(haploid_lowd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_lowd__set_genotypes(self, *args, **kwargs)

    def set_genotypes(self, genotypes, counts):
        '''Initialize population with fixed counts for specific genotypes.

        Parameters:
           - genotypes: list of genotypes to set. Genotypes are specified as integers,
                        from 00...0 that is 0, up to 11...1 that is 2^L-1.
           - counts: list of counts for those genotypes

        .. note:: the population size and, if unset, the carrying capacity will be set as the sum of the counts.
        .. note:: you can use Python binary notation for the indices, e.g. 0b0110 is 6.
        '''
        genotypes = _np.asarray(genotypes, float)
        counts = _np.asarray(counts, float)
        if len(genotypes) != len(counts):
            raise ValueError('Indices and counts must have the same length')
        if self._set_genotypes(genotypes, counts):
            raise RuntimeError('Error in the C++ function.')

    def get_recombination_rates(self):
        '''Get recombination rates.

    Returns:
        - the rates between neighboring loci, a list of float of length L-1

    .. note:: if the recombination model if FREE_RECOMBINATION, an error is raised.
        '''
        if self.L < 2:
            raise ValueError('There is no recombination with less than 2 loci.')

        rm = self.recombination_model
        if rm == 1:
            raise ValueError(('The current recombination model is free recombination,'+
                              'hence recombination rates are not defined.'+
                              ' Could you possibly mean outcrossing rate?'))
        elif rm in [3, 2]:
            return _np.array([self.get_recombination_rate(i) for i in xrange(self.L - 1)])
        else:
            raise RuntimeError('Recombination model not found')

    def set_recombination_rates(self, rates, model=None):
        '''Set the recombination rate(s).

    Parameters:
        - rates: if a double, the recombination rate at between any two loci; if an array,
          the locus-specific recombination rates
        - model: the recombination model to use (CROSSOVERS or, for linear
          genomes, SINGLE_CROSSOVER)

    .. note:: if locus-specific rates are specified, the array must have length
              (L-1) for linear chromosomes and length L for circular ones. The
              i-th element is the crossover rate between the i-th site and the
              (i+1)-th site.

    .. note:: if the recombination model is not specified, the current model will be kept or,
              if the current model is FREE_RECOMBINATION, then CROSSOVERS will be set.
        '''

        
        if model is None:
            if self.recombination_model != 1:
                model = self.recombination_model
            else:
                model = 2

        
        if model == 1:
            raise ValueError("Cannot assign rates to free recombination!")
        if model not in (2, 3):
            raise ValueError("Model not recognized.")
        if (self.circular and (model == 3)):
            raise ValueError("Single crossover not available for circular genomes.") 

        
        if self.circular:
            len_rates = self.L
        else:
            len_rates = self.L - 1

        
        if _np.isscalar(rates):
            self._set_recombination_rates([rates] * len_rates, model)

        elif len(rates) != len_rates:
            raise ValueError("Expecting an array of length "+str(len_rates)+".")
        else:
            self._set_recombination_rates(rates, model)


    def get_mutation_rates(self, locus=None, direction=None):
        '''Get one or several mutation rates.

    Parameters:
        - locus: get only the mutation rate(s) of this locus
        - direction: get only the forward or backward mutation rate(s). This argument
                     is a Boolean, 0/False for forward rates, 1/True for backward rates.

    Returns:
        - the mutation rate(s) requested

    **Note**: if the mutation rates for all loci and/or directions are the same,
    this function will try to be smart and give you the answer you are looking for.
    In case of doubt, you will get a matrix (L x 2) with the full mutation rate
    landscape.
        '''

        if locus is not None:
            if not _np.isscalar(locus):
                raise TypeError('Please select a *single* locus or no locus at all.')
            if direction is not None:
                return self._get_mutation_rate(locus, direction)
            else:
                mrs = tuple([self._get_mutation_rate(locus, d) for d in [0,1]])
                if mrs[0] == mrs[1]:
                    return mrs[0]
                else:
                    return mrs
        else:
            if direction is not None:
                mrs = _np.array([self._get_mutation_rate(l, direction) for l in xrange(self.L)])
                if len(_np.unique(mrs)) == 1:
                    return mrs[0]
                else:
                    return mrs
            else:
                mrs = _np.array([[self._get_mutation_rate(l, d) for l in xrange(self.L)] for d in [0,1]])
                if len(_np.unique(mrs)) == 1:
                    return mrs[0,0]
                else:
                    return mrs

    def _set_mutation_rates(self, *args, **kwargs):
        """_set_mutation_rates(haploid_lowd self, double * IN_ARRAY2) -> int"""
        return _FFPopSim.haploid_lowd__set_mutation_rates(self, *args, **kwargs)

    def set_mutation_rates(self, rates, rates_back=None):
        '''Set the mutation rate(s).

    Parameters:
        - rates:if a double, the mutation rate at any locus in both directions
          or, if rates_back is not None, only in the forward direction

          if a vector, the mutation rate is specified for each locus, the same
          in both directions or, if rates_back is not None, only in the
          forward direction

        - rates_back: mutation rate in the backward direction (global or
          locus-specific)
        '''

        L = self.L
        if _np.isscalar(rates):
            if rates_back is None:
                ratesm = _np.repeat(rates, L * 2).reshape(2,L)
            else:
                ratesm = _np.vstack([_np.repeat(rates, L), _np.repeat(rates_back, L)])
        elif (_np.rank(rates) != 1) or ((rates_back is not None) and (_np.rank(rates_back) != 1)):
            raise ValueError('Please input one/two numbers or arrays.')
        else:
            if rates_back is None:
                ratesm = _np.vstack([rates, rates])
            else:
                ratesm = _np.vstack([rates, rates_back])

        if self._set_mutation_rates(ratesm):
            raise RuntimeError('Error in the C++ function.')

    def get_genotype_frequencies(self):
        '''Get the frequency of each genotype.'''
        return _np.array([self.get_genotype_frequency(l) for l in xrange(1<<self.L)])

    def get_allele_frequencies(self):
        '''Get the frequencies of all + alleles'''
        return _np.array([self.get_allele_frequency(l) for l in xrange(self.L)])

    def random_genomes(self, n_sample):
        '''Get random genomes according sampled from the population. 
        
        Parameters:
            - n_sample: number of random genomes to sample
        
        Returns:
            - integers corresponding to random genomes in the population.
        '''
        counts = _np.random.multinomial(n_sample, self.get_genotype_frequencies())
        ind = counts.nonzero()[0]
        counts = counts[ind]
        sample = _np.concatenate([_np.repeat(ind[i], counts[i]) for i in xrange(len(ind))])
        _np.random.shuffle(sample)
        return sample

    def get_fitnesses(self, *args, **kwargs):
        """Get the fitness of all possible genotypes."""
        args = tuple([1<<self.L] + list(args))


        return _FFPopSim.haploid_lowd_get_fitnesses(self, *args, **kwargs)

    def get_fitness_histogram(self, n_sample=1000, **kwargs):
        '''Get the histogram of the fitness of a sample from the population.

        Parameters:
            - n_sample: number of individual to sample at random from the population. defaults to 1000

        Returns:
           - h: numpy.histogram of fitness in the population
        '''

        
        gt = self.random_genomes(n_sample)

        
        fit = _np.array([self.get_fitness(gt[i]) for i in xrange(n_sample)])

        return _np.histogram(fit, **kwargs)


    def plot_fitness_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the fitness of a sample from the population.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population. Defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms
        '''

        import matplotlib.pyplot as plt

        
        gt = self.random_genomes(n_sample)

        
        fit = _np.array([self.get_fitness(gt[i]) for i in xrange(n_sample)])

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Fitness histogram')
            axis.set_xlabel('Fitness')
        axis.hist(fit, **kwargs)


    def get_divergence_statistics(self, n_sample=1000):
        '''Get the mean and variance of the divergence of a population sample -- same as mean and variance of allele frequencies.

        Parameters:
            - n_sample: number of individuals to sample at random from the population. defaults to 1000.

        Returns:
            - stat: structure with mean and variance of divergence in the population
        '''

        L = self.L

        
        gt = self.random_genomes(n_sample)

        
        div = _np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_divergence_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the divergence of a population sample.

        Parameters:
            - bins: number of bins or list of bin edges (passed verbatim to numpy.histogram)
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms

        Returns:
           - h: numpy.histogram of divergence in the population

        *Note*: to get a normalized histogram, use the *density* keyword.
        '''

        
        gt = self.random_genomes(n_sample)

        
        div = _np.array([binarify(gt[i], self.L).sum() for i in xrange(n_sample)], int)

        return _np.histogram(div, bins=bins, **kwargs)


    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the divergence of a population sample.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms
        '''
        import matplotlib.pyplot as plt
        L = self.L

        
        gt = self.random_genomes(n_sample)

        
        div = _np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Divergence histogram')
            axis.set_xlabel('Divergence')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)


    def get_diversity_statistics(self, n_sample=1000):
        '''Get the mean and variance of the diversity of a population sample

        Parameters:
            - n_sample: number of individual to sample at random from the population, defaults to 1000.

        Returns:
            - stat: structure with mean and variance of diversity in the population
        '''

        
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

        
        div = _np.array([binarify(gt1[i] ^ gt2[i], self.L).sum() for i in xrange(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_diversity_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the diversity in a sample from the population.

        Parameters:
            - bins: number of bins or list of bin edges (passed verbatim to numpy.histogram)
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms

        Returns:
           - h: numpy.histogram of diversity in the population

        *Note*: to get a normalized histogram, use the *density* keyword.
        '''

        
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

        
        div = _np.array([binarify(gt1[i] ^ gt2[i], self.L).sum() for i in xrange(n_sample)], int)

        
        return _np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the diversity of a population sample.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms
        '''
        import matplotlib.pyplot as plt

        
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

        
        div = _np.array([binarify(gt1[i] ^ gt2[i], self.L).sum() for i in xrange(n_sample)], int)

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Diversity histogram')
            axis.set_xlabel('Diversity')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)

    def _set_fitness_func(self, *args, **kwargs):
        """_set_fitness_func(haploid_lowd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_lowd__set_fitness_func(self, *args, **kwargs)

    def _set_fitness_coeff(self, *args, **kwargs):
        """_set_fitness_coeff(haploid_lowd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_lowd__set_fitness_coeff(self, *args, **kwargs)

    def set_fitness_function(self, genotypes, values):
        '''Set the fitness landscape for individual genotypes.

        Parameters:
           - genotypes: genotype to which the fitness values will be assigned. Genotypes are specified as integers,
                        from 00...0 that is 0, up to 11...1 that is 2^L-1.
           - values: fitness values to assign

        .. note:: you can use Python binary notation for the genotypes, e.g. 0b0110 is 6.
        '''
        genotypes = _np.asarray(genotypes, float)
        values = _np.asarray(values, float)
        if len(genotypes) != len(values):
            raise ValueError('Indices and values must have the same length')
        if self._set_fitness_func(genotypes, values):
            raise RuntimeError('Error in the C++ function.')


    def set_fitness_coefficients(self, coefficients, values):
        '''Set the fitness landscape in Fourier space for individual Fourier coefficients.

        Parameters:
           - coefficients: Fourier coefficients to which the values will be assigned. They are specified
                           as integers, from 00...0 that is 0, up to 11...1 that is 2^L-1.
           - values: values to assign

        .. note:: you can use Python binary notation for the coefficients, e.g. 0b0110 is 6.
        '''
        coefficients = _np.asarray(coefficients, float)
        values = _np.asarray(values, float)
        if len(coefficients) != len(values):
            raise ValueError('Indices and values must have the same length')
        if self._set_fitness_coeff(coefficients, values):
            raise RuntimeError('Error in the C++ function.')


    def set_fitness_additive(self, *args, **kwargs):
        """
        Set an additive fitness landscape. Coefficients obey +/- convention.

        Parameters:
            - coefficients: array/list of additive fitness coefficients. It must have length L.

        """
        return _FFPopSim.haploid_lowd_set_fitness_additive(self, *args, **kwargs)

haploid_lowd._get_mutation_rate = new_instancemethod(_FFPopSim.haploid_lowd__get_mutation_rate,None,haploid_lowd)
haploid_lowd._get_recombination_model = new_instancemethod(_FFPopSim.haploid_lowd__get_recombination_model,None,haploid_lowd)
haploid_lowd._set_recombination_model = new_instancemethod(_FFPopSim.haploid_lowd__set_recombination_model,None,haploid_lowd)
haploid_lowd._set_recombination_rates = new_instancemethod(_FFPopSim.haploid_lowd__set_recombination_rates,None,haploid_lowd)
haploid_lowd.genotype_entropy = new_instancemethod(_FFPopSim.haploid_lowd_genotype_entropy,None,haploid_lowd)
haploid_lowd.allele_entropy = new_instancemethod(_FFPopSim.haploid_lowd_allele_entropy,None,haploid_lowd)
haploid_lowd.get_fitness_statistics = new_instancemethod(_FFPopSim.haploid_lowd_get_fitness_statistics,None,haploid_lowd)
haploid_lowd.__str__ = new_instancemethod(_FFPopSim.haploid_lowd___str__,None,haploid_lowd)
haploid_lowd.__repr__ = new_instancemethod(_FFPopSim.haploid_lowd___repr__,None,haploid_lowd)
haploid_lowd._set_genotypes = new_instancemethod(_FFPopSim.haploid_lowd__set_genotypes,None,haploid_lowd)
haploid_lowd._set_mutation_rates = new_instancemethod(_FFPopSim.haploid_lowd__set_mutation_rates,None,haploid_lowd)
haploid_lowd._set_fitness_func = new_instancemethod(_FFPopSim.haploid_lowd__set_fitness_func,None,haploid_lowd)
haploid_lowd._set_fitness_coeff = new_instancemethod(_FFPopSim.haploid_lowd__set_fitness_coeff,None,haploid_lowd)
haploid_lowd.set_fitness_additive = new_instancemethod(_FFPopSim.haploid_lowd_set_fitness_additive,None,haploid_lowd)
haploid_lowd_swigregister = _FFPopSim.haploid_lowd_swigregister
haploid_lowd_swigregister(haploid_lowd)

HCF_MEMERR = _FFPopSim.HCF_MEMERR
HCF_BADARG = _FFPopSim.HCF_BADARG
HCF_VERBOSE = _FFPopSim.HCF_VERBOSE
WORDLENGTH = _FFPopSim.WORDLENGTH
HP_VERBOSE = _FFPopSim.HP_VERBOSE
NO_GENOTYPE = _FFPopSim.NO_GENOTYPE
HP_MINAF = _FFPopSim.HP_MINAF
MAX_DELTAFITNESS = _FFPopSim.MAX_DELTAFITNESS
MAX_POPSIZE = _FFPopSim.MAX_POPSIZE
HP_NOTHING = _FFPopSim.HP_NOTHING
HP_RANDOM_SAMPLE_FRAC = _FFPopSim.HP_RANDOM_SAMPLE_FRAC
HP_VERY_NEGATIVE = _FFPopSim.HP_VERY_NEGATIVE
HP_BADARG = _FFPopSim.HP_BADARG
HP_MEMERR = _FFPopSim.HP_MEMERR
HP_EXPLOSIONWARN = _FFPopSim.HP_EXPLOSIONWARN
HP_EXTINCTERR = _FFPopSim.HP_EXTINCTERR
HP_NOBINSERR = _FFPopSim.HP_NOBINSERR
HP_WRONGBINSERR = _FFPopSim.HP_WRONGBINSERR
HP_RUNTIMEERR = _FFPopSim.HP_RUNTIMEERR
class clone(object):
    """Clone of isogenetic individuals"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    genotype = _swig_property(_FFPopSim.clone_genotype_get, _FFPopSim.clone_genotype_set)
    fitness = _swig_property(_FFPopSim.clone_fitness_get, _FFPopSim.clone_fitness_set)
    clone_size = _swig_property(_FFPopSim.clone_clone_size_get, _FFPopSim.clone_clone_size_set)
    def __init__(self, n_traits=0): 
        """Clone of isogenetic individuals"""
        _FFPopSim.clone_swiginit(self,_FFPopSim.new_clone(n_traits))
    def __eq__(self, *args, **kwargs):
        """__eq__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___ne__(self, *args, **kwargs)

    def __lt__(self, *args, **kwargs):
        """__lt__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___lt__(self, *args, **kwargs)

    def __gt__(self, *args, **kwargs):
        """__gt__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___gt__(self, *args, **kwargs)

    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.clone___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.clone___repr__(self)

    number_of_traits = _swig_property(_FFPopSim.clone_number_of_traits_get)
    def _get_trait(self, *args, **kwargs):
        """_get_trait(clone self, int DIM1)"""
        return _FFPopSim.clone__get_trait(self, *args, **kwargs)

    @property
    def trait(self):
        '''Traits vector of the clone'''
        return self._get_trait(self.number_of_traits)

    __swig_destroy__ = _FFPopSim.delete_clone
clone.__eq__ = new_instancemethod(_FFPopSim.clone___eq__,None,clone)
clone.__ne__ = new_instancemethod(_FFPopSim.clone___ne__,None,clone)
clone.__lt__ = new_instancemethod(_FFPopSim.clone___lt__,None,clone)
clone.__gt__ = new_instancemethod(_FFPopSim.clone___gt__,None,clone)
clone.__str__ = new_instancemethod(_FFPopSim.clone___str__,None,clone)
clone.__repr__ = new_instancemethod(_FFPopSim.clone___repr__,None,clone)
clone._get_trait = new_instancemethod(_FFPopSim.clone__get_trait,None,clone)
clone_swigregister = _FFPopSim.clone_swigregister
clone_swigregister(clone)

RT_VERBOSE = _FFPopSim.RT_VERBOSE
RT_VERYLARGE = _FFPopSim.RT_VERYLARGE
RT_CHILDNOTFOUND = _FFPopSim.RT_CHILDNOTFOUND
RT_NODENOTFOUND = _FFPopSim.RT_NODENOTFOUND
class tree_key(object):
    """Key for a phylogenetic tree, with index and age."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    index = _swig_property(_FFPopSim.tree_key_index_get, _FFPopSim.tree_key_index_set)
    age = _swig_property(_FFPopSim.tree_key_age_get, _FFPopSim.tree_key_age_set)
    def __eq__(self, *args, **kwargs):
        """__eq__(tree_key self, tree_key other) -> bool"""
        return _FFPopSim.tree_key___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(tree_key self, tree_key other) -> bool"""
        return _FFPopSim.tree_key___ne__(self, *args, **kwargs)

    def __lt__(self, *args, **kwargs):
        """__lt__(tree_key self, tree_key other) -> bool"""
        return _FFPopSim.tree_key___lt__(self, *args, **kwargs)

    def __gt__(self, *args, **kwargs):
        """__gt__(tree_key self, tree_key other) -> bool"""
        return _FFPopSim.tree_key___gt__(self, *args, **kwargs)

    def __init__(self, index=0, age=0): 
        """
        Initialize new tree_key.

        Parameters:
           - index: index of the key
           - age: age of the key

        """
        _FFPopSim.tree_key_swiginit(self,_FFPopSim.new_tree_key(index, age))
    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.tree_key___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.tree_key___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_tree_key
tree_key.__eq__ = new_instancemethod(_FFPopSim.tree_key___eq__,None,tree_key)
tree_key.__ne__ = new_instancemethod(_FFPopSim.tree_key___ne__,None,tree_key)
tree_key.__lt__ = new_instancemethod(_FFPopSim.tree_key___lt__,None,tree_key)
tree_key.__gt__ = new_instancemethod(_FFPopSim.tree_key___gt__,None,tree_key)
tree_key.__str__ = new_instancemethod(_FFPopSim.tree_key___str__,None,tree_key)
tree_key.__repr__ = new_instancemethod(_FFPopSim.tree_key___repr__,None,tree_key)
tree_key_swigregister = _FFPopSim.tree_key_swigregister
tree_key_swigregister(tree_key)

class tree_step(object):
    """Step in a phylogenetic tree search"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    pos = _swig_property(_FFPopSim.tree_step_pos_get, _FFPopSim.tree_step_pos_set)
    step = _swig_property(_FFPopSim.tree_step_step_get, _FFPopSim.tree_step_step_set)
    def __lt__(self, *args, **kwargs):
        """__lt__(tree_step self, tree_step other) -> bool"""
        return _FFPopSim.tree_step___lt__(self, *args, **kwargs)

    def __gt__(self, *args, **kwargs):
        """__gt__(tree_step self, tree_step other) -> bool"""
        return _FFPopSim.tree_step___gt__(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(tree_step self, tree_step other) -> bool"""
        return _FFPopSim.tree_step___eq__(self, *args, **kwargs)

    def __init__(self, pos=0, step=0): 
        """
        Initialize new step.

        Parameters:
           - pos: position
           - step: length of step

        """
        _FFPopSim.tree_step_swiginit(self,_FFPopSim.new_tree_step(pos, step))
    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.tree_step___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.tree_step___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_tree_step
tree_step.__lt__ = new_instancemethod(_FFPopSim.tree_step___lt__,None,tree_step)
tree_step.__gt__ = new_instancemethod(_FFPopSim.tree_step___gt__,None,tree_step)
tree_step.__eq__ = new_instancemethod(_FFPopSim.tree_step___eq__,None,tree_step)
tree_step.__str__ = new_instancemethod(_FFPopSim.tree_step___str__,None,tree_step)
tree_step.__repr__ = new_instancemethod(_FFPopSim.tree_step___repr__,None,tree_step)
tree_step_swigregister = _FFPopSim.tree_step_swigregister
tree_step_swigregister(tree_step)

class tree_node(object):
    """Node of a phylogenetic tree"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    parent_node = _swig_property(_FFPopSim.tree_node_parent_node_get, _FFPopSim.tree_node_parent_node_set)
    _child_edges = _swig_property(_FFPopSim.tree_node__child_edges_get, _FFPopSim.tree_node__child_edges_set)
    fitness = _swig_property(_FFPopSim.tree_node_fitness_get, _FFPopSim.tree_node_fitness_set)
    own_key = _swig_property(_FFPopSim.tree_node_own_key_get, _FFPopSim.tree_node_own_key_set)
    _weight_distribution = _swig_property(_FFPopSim.tree_node__weight_distribution_get, _FFPopSim.tree_node__weight_distribution_set)
    number_of_offspring = _swig_property(_FFPopSim.tree_node_number_of_offspring_get, _FFPopSim.tree_node_number_of_offspring_set)
    clone_size = _swig_property(_FFPopSim.tree_node_clone_size_get, _FFPopSim.tree_node_clone_size_set)
    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.tree_node___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.tree_node___repr__(self)

    @property
    def child_edges(self):
        '''Child edges of the node'''
        return list(self._child_edges)


    @child_edges.setter
    def child_edges(self, es):
        self._child_edges = list_tree_key(es)

    def _get_crossover_chunk(self, *args, **kwargs):
        """_get_crossover_chunk(tree_node self, int i) -> int"""
        return _FFPopSim.tree_node__get_crossover_chunk(self, *args, **kwargs)

    @property
    def crossover(self):
        '''Crossover of node'''
        return [self._get_crossover_chunk(i) for i in xrange(2)]

    @property
    def weight_distribution(self):
        '''Distribution of weights of this node'''
        return list(self._weight_distribution)

    @weight_distribution.setter
    def weight_distribution(self, distr):
        self._weight_distribution = vector_tree_step(distr)

    def __init__(self): 
        """Node of a phylogenetic tree"""
        _FFPopSim.tree_node_swiginit(self,_FFPopSim.new_tree_node())
    __swig_destroy__ = _FFPopSim.delete_tree_node
tree_node.__str__ = new_instancemethod(_FFPopSim.tree_node___str__,None,tree_node)
tree_node.__repr__ = new_instancemethod(_FFPopSim.tree_node___repr__,None,tree_node)
tree_node._get_crossover_chunk = new_instancemethod(_FFPopSim.tree_node__get_crossover_chunk,None,tree_node)
tree_node_swigregister = _FFPopSim.tree_node_swigregister
tree_node_swigregister(tree_node)

class tree_edge(object):
    """Edge of a phylogenetic tree"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    parent_node = _swig_property(_FFPopSim.tree_edge_parent_node_get, _FFPopSim.tree_edge_parent_node_set)
    own_key = _swig_property(_FFPopSim.tree_edge_own_key_get, _FFPopSim.tree_edge_own_key_set)
    length = _swig_property(_FFPopSim.tree_edge_length_get, _FFPopSim.tree_edge_length_set)
    number_of_offspring = _swig_property(_FFPopSim.tree_edge_number_of_offspring_get, _FFPopSim.tree_edge_number_of_offspring_set)
    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.tree_edge___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.tree_edge___repr__(self)

    def _get_segment_chunk(self, *args, **kwargs):
        """_get_segment_chunk(tree_edge self, int i) -> int"""
        return _FFPopSim.tree_edge__get_segment_chunk(self, *args, **kwargs)

    @property
    def segment(self):
        '''Segment of edge'''
        return [self._get_segment_chunk(i) for i in xrange(2)]

    def __init__(self): 
        """Edge of a phylogenetic tree"""
        _FFPopSim.tree_edge_swiginit(self,_FFPopSim.new_tree_edge())
    __swig_destroy__ = _FFPopSim.delete_tree_edge
tree_edge.__str__ = new_instancemethod(_FFPopSim.tree_edge___str__,None,tree_edge)
tree_edge.__repr__ = new_instancemethod(_FFPopSim.tree_edge___repr__,None,tree_edge)
tree_edge._get_segment_chunk = new_instancemethod(_FFPopSim.tree_edge__get_segment_chunk,None,tree_edge)
tree_edge_swigregister = _FFPopSim.tree_edge_swigregister
tree_edge_swigregister(tree_edge)

class polymorphism(object):
    """Polymorphism history"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    birth = _swig_property(_FFPopSim.polymorphism_birth_get, _FFPopSim.polymorphism_birth_set)
    sweep_time = _swig_property(_FFPopSim.polymorphism_sweep_time_get, _FFPopSim.polymorphism_sweep_time_set)
    effect = _swig_property(_FFPopSim.polymorphism_effect_get, _FFPopSim.polymorphism_effect_set)
    fitness = _swig_property(_FFPopSim.polymorphism_fitness_get, _FFPopSim.polymorphism_fitness_set)
    fitness_variance = _swig_property(_FFPopSim.polymorphism_fitness_variance_get, _FFPopSim.polymorphism_fitness_variance_set)
    def __init__(self, b=0, age=0, e=0, f=0, fvar=0): 
        """Polymorphism history"""
        _FFPopSim.polymorphism_swiginit(self,_FFPopSim.new_polymorphism(b, age, e, f, fvar))
    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.polymorphism___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.polymorphism___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_polymorphism
polymorphism.__str__ = new_instancemethod(_FFPopSim.polymorphism___str__,None,polymorphism)
polymorphism.__repr__ = new_instancemethod(_FFPopSim.polymorphism___repr__,None,polymorphism)
polymorphism_swigregister = _FFPopSim.polymorphism_swigregister
polymorphism_swigregister(polymorphism)

class rooted_tree(object):
    """
    Rooted phylogenetic tree.

    This class is used to represent the phylogenetic tree of a single locus.
    It is possible to print the tree in Newick format, to get the subtree
    spanned by some of the leaves, and to look at the tree nodes and edges.

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _edges = _swig_property(_FFPopSim.rooted_tree__edges_get, _FFPopSim.rooted_tree__edges_set)
    _nodes = _swig_property(_FFPopSim.rooted_tree__nodes_get, _FFPopSim.rooted_tree__nodes_set)
    _leafs = _swig_property(_FFPopSim.rooted_tree__leafs_get, _FFPopSim.rooted_tree__leafs_set)
    root = _swig_property(_FFPopSim.rooted_tree_root_get, _FFPopSim.rooted_tree_root_set)
    MRCA = _swig_property(_FFPopSim.rooted_tree_MRCA_get, _FFPopSim.rooted_tree_MRCA_set)
    def __init__(self): 
        """
        Rooted phylogenetic tree.

        This class is used to represent the phylogenetic tree of a single locus.
        It is possible to print the tree in Newick format, to get the subtree
        spanned by some of the leaves, and to look at the tree nodes and edges.

        """
        _FFPopSim.rooted_tree_swiginit(self,_FFPopSim.new_rooted_tree())
    __swig_destroy__ = _FFPopSim.delete_rooted_tree
    def external_branch_length(self):
        """
        Measure the length of the external branches.

        Returns:
           - length: the sum of the lengths of the external branches.

        """
        return _FFPopSim.rooted_tree_external_branch_length(self)

    def total_branch_length(self):
        """
        Measure the length of the branches.

        Returns:
           - length: the sum of the lengths of all branches.

        """
        return _FFPopSim.rooted_tree_total_branch_length(self)

    def calc_weight_distribution(self, *args, **kwargs):
        """
        Recalculate the weight of some internal nodes.

        Parameters:
           - subtree_root: the node whose hanging subtree is recalculated

        Returns:
           - error code: zero if successful

        """
        return _FFPopSim.rooted_tree_calc_weight_distribution(self, *args, **kwargs)

    def print_newick(self):
        """print_newick(rooted_tree self) -> std::string"""
        return _FFPopSim.rooted_tree_print_newick(self)

    def subtree_newick(self, *args, **kwargs):
        """subtree_newick(rooted_tree self, tree_key root) -> std::string"""
        return _FFPopSim.rooted_tree_subtree_newick(self, *args, **kwargs)

    def print_weight_distribution(self, *args, **kwargs):
        """print_weight_distribution(rooted_tree self, tree_key node_key) -> std::string"""
        return _FFPopSim.rooted_tree_print_weight_distribution(self, *args, **kwargs)

    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.rooted_tree___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.rooted_tree___repr__(self)

    def _ancestors_at_age(self, *args, **kwargs):
        """_ancestors_at_age(rooted_tree self, int age, tree_key subtree_root) -> vector_tree_key"""
        return _FFPopSim.rooted_tree__ancestors_at_age(self, *args, **kwargs)

    def ancestors_at_age(self, age, subtree):
        '''Find nodes in subtree younger than a certain age
        
        Parameters:
           - age: critical age to check
           - subtree: subtree to look for nodes in
        
        Returns:
           - ancestors: the ancestors at that age
        '''
        return list(self._ancestors_at_age(age, subtree))

    def create_subtree_from_keys(self, *args, **kwargs):
        """
        Create a subtree from a list of leaves.

        Parameters:
           - leaves: the leaves used to contruct the subtree

        Returns:
           - subtree: the subtree spanned by those leaves.

        .. note:: leaves can be a Python list or a numpy array of tree_key, or a vector_tree_key.

        """
        return _FFPopSim.rooted_tree_create_subtree_from_keys(self, *args, **kwargs)

    @property
    def edges(self):
        '''Edges of the tree'''
        return dict(self._edges)


    @edges.setter
    def edges(self, es):
        self._edges = map_key_edge(es)

    @property
    def nodes(self):
        '''Nodes of the tree'''
        return dict(self._nodes)


    @nodes.setter
    def edges(self, ns):
        self._nodes = map_key_node(ns)

    @property
    def leafs(self):
        '''Leaves of the tree'''
        return list(self._leafs)


    @leafs.setter
    def leafs(self, leaves):
        self._leafs = vector_tree_key(leaves)

    def to_Biopython_tree(self):
        '''Convert the tree into Biopython format
        
        Returns:
           - tree: Biopython.Phylo phylogenetic tree representation of self
        '''
        from cStringIO import StringIO
        from Bio import Phylo
         
        treedata = self.print_newick()
        handle = StringIO(treedata)
        tree = Phylo.read(handle, "newick")
        return tree

rooted_tree.external_branch_length = new_instancemethod(_FFPopSim.rooted_tree_external_branch_length,None,rooted_tree)
rooted_tree.total_branch_length = new_instancemethod(_FFPopSim.rooted_tree_total_branch_length,None,rooted_tree)
rooted_tree.calc_weight_distribution = new_instancemethod(_FFPopSim.rooted_tree_calc_weight_distribution,None,rooted_tree)
rooted_tree.print_newick = new_instancemethod(_FFPopSim.rooted_tree_print_newick,None,rooted_tree)
rooted_tree.subtree_newick = new_instancemethod(_FFPopSim.rooted_tree_subtree_newick,None,rooted_tree)
rooted_tree.print_weight_distribution = new_instancemethod(_FFPopSim.rooted_tree_print_weight_distribution,None,rooted_tree)
rooted_tree.__str__ = new_instancemethod(_FFPopSim.rooted_tree___str__,None,rooted_tree)
rooted_tree.__repr__ = new_instancemethod(_FFPopSim.rooted_tree___repr__,None,rooted_tree)
rooted_tree._ancestors_at_age = new_instancemethod(_FFPopSim.rooted_tree__ancestors_at_age,None,rooted_tree)
rooted_tree.create_subtree_from_keys = new_instancemethod(_FFPopSim.rooted_tree_create_subtree_from_keys,None,rooted_tree)
rooted_tree_swigregister = _FFPopSim.rooted_tree_swigregister
rooted_tree_swigregister(rooted_tree)

class multi_locus_genealogy(object):
    """Genealogy for multiple loci"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self): 
        """Default constructor"""
        _FFPopSim.multi_locus_genealogy_swiginit(self,_FFPopSim.new_multi_locus_genealogy())
    __swig_destroy__ = _FFPopSim.delete_multi_locus_genealogy
    def track_locus(self, *args, **kwargs):
        """
        Start tracking a new locus.

        Parameters:
           - new_locus: locus to be tracked

        .. note:: the locus gets appended to the 'loci' array.

        """
        return _FFPopSim.multi_locus_genealogy_track_locus(self, *args, **kwargs)

    def reset(self):
        """Reset (empty) the genealogy."""
        return _FFPopSim.multi_locus_genealogy_reset(self)

    def reset_but_loci(self):
        """reset_but_loci(multi_locus_genealogy self)"""
        return _FFPopSim.multi_locus_genealogy_reset_but_loci(self)

    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.multi_locus_genealogy___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.multi_locus_genealogy___repr__(self)

    def _get_number_of_loci(self):
        """_get_number_of_loci(multi_locus_genealogy self) -> int"""
        return _FFPopSim.multi_locus_genealogy__get_number_of_loci(self)

    def _get_loci(self, *args, **kwargs):
        """_get_loci(multi_locus_genealogy self, int DIM1)"""
        return _FFPopSim.multi_locus_genealogy__get_loci(self, *args, **kwargs)

    @property
    def loci(self):
        '''The loci that are being tracked'''
        return self._get_loci(self._get_number_of_loci())

    def get_tree(self, *args, **kwargs):
        """
        Get the genealogy tree for a certain locus.

        Parameters:
           - locus: site whose tree is being returned

        .. note:: if you want to know what loci are being tracked, look into the 'loci'
                  attribute.

        """
        return _FFPopSim.multi_locus_genealogy_get_tree(self, *args, **kwargs)

multi_locus_genealogy.track_locus = new_instancemethod(_FFPopSim.multi_locus_genealogy_track_locus,None,multi_locus_genealogy)
multi_locus_genealogy.reset = new_instancemethod(_FFPopSim.multi_locus_genealogy_reset,None,multi_locus_genealogy)
multi_locus_genealogy.reset_but_loci = new_instancemethod(_FFPopSim.multi_locus_genealogy_reset_but_loci,None,multi_locus_genealogy)
multi_locus_genealogy.__str__ = new_instancemethod(_FFPopSim.multi_locus_genealogy___str__,None,multi_locus_genealogy)
multi_locus_genealogy.__repr__ = new_instancemethod(_FFPopSim.multi_locus_genealogy___repr__,None,multi_locus_genealogy)
multi_locus_genealogy._get_number_of_loci = new_instancemethod(_FFPopSim.multi_locus_genealogy__get_number_of_loci,None,multi_locus_genealogy)
multi_locus_genealogy._get_loci = new_instancemethod(_FFPopSim.multi_locus_genealogy__get_loci,None,multi_locus_genealogy)
multi_locus_genealogy.get_tree = new_instancemethod(_FFPopSim.multi_locus_genealogy_get_tree,None,multi_locus_genealogy)
multi_locus_genealogy_swigregister = _FFPopSim.multi_locus_genealogy_swigregister
multi_locus_genealogy_swigregister(multi_locus_genealogy)

class haploid_highd(object):
    """
    Class for high-dimensional population genetics (genomes larger than ~20 loci).

    This class is the main object for simulating the evolution of populations with
    many loci (more than ~20). The class offers a number of functions, but an
    example will explain the basic idea::

       ######################################
       #  EXAMPLE SCRIPT FOR HAPLOID_HIGHD  #
       ######################################
       import numpy as np
       import matplotlib.pyplot as plt
       import FFPopSim as h
       c = h.haploid_highd(300)       # 300 loci
       pop.set_wildtype(1000)         # start with 1000 wildtype individuals
       pop.mutation_rate = 1e-4       # mutation rate per site per generation
       pop.outcrossing_rate = 1e-1    # probability of sexual reproduction per gen
       pop.crossover_rate = 1e-2      # probability of crossover per site per gen
       pop.evolve(100)                # evolve for 100 generations
       c.plot_divergence_histogram()
       plt.show()
       ######################################

    Populations can have a number of phenotypic traits that contribute to the fitness
    of each individual. The function that calculates fitness from the phenotype
    identifies fitness with the first trait only by default. The user is, however,
    free to subclass haploid_highd in C++ (as it is done in hivpopulation) and
    implement their own phenotype -> fitness function.

    In addition, the trait landscapes describe the genotype -> phenotype maps.
    These can be set directly from Python (since the genotypic space has a finite
    number of elements).

    **Note**: fitness is not a phenotypic trait directly, but rather a function of *all*
    phenotypic traits together. 

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, L=0, rng_seed=0, number_of_traits=1, all_polymorphic=False): 
        """
        Construct a high-dimensional population with certain parameters.

        Parameters:
           - L: number of loci
           - rng_seed: seed for the random generator. If zero (default) pick a random number
           - number_of_traits: number of phenotypic traits, defaults to one
           - all_polymorphic: option to use an infinite-sites model tracking ancestral alleles
                              (only available with a single phenotypic trait and zero mutation rate)

        """
        _FFPopSim.haploid_highd_swiginit(self,_FFPopSim.new_haploid_highd(L, rng_seed, number_of_traits, all_polymorphic))
    __swig_destroy__ = _FFPopSim.delete_haploid_highd
    carrying_capacity = _swig_property(_FFPopSim.haploid_highd_carrying_capacity_get, _FFPopSim.haploid_highd_carrying_capacity_set)
    outcrossing_rate = _swig_property(_FFPopSim.haploid_highd_outcrossing_rate_get, _FFPopSim.haploid_highd_outcrossing_rate_set)
    crossover_rate = _swig_property(_FFPopSim.haploid_highd_crossover_rate_get, _FFPopSim.haploid_highd_crossover_rate_set)
    recombination_model = _swig_property(_FFPopSim.haploid_highd_recombination_model_get, _FFPopSim.haploid_highd_recombination_model_set)
    circular = _swig_property(_FFPopSim.haploid_highd_circular_get, _FFPopSim.haploid_highd_circular_set)
    def _get_mutation_rate(self):
        """_get_mutation_rate(haploid_highd self) -> double"""
        return _FFPopSim.haploid_highd__get_mutation_rate(self)

    def _set_mutation_rate(self, *args, **kwargs):
        """_set_mutation_rate(haploid_highd self, double m)"""
        return _FFPopSim.haploid_highd__set_mutation_rate(self, *args, **kwargs)

    def _get_polymorphisms(self):
        """_get_polymorphisms(haploid_highd self) -> vector_polymorphism"""
        return _FFPopSim.haploid_highd__get_polymorphisms(self)

    def _get_fixed_mutations(self):
        """_get_fixed_mutations(haploid_highd self) -> vector_polymorphism"""
        return _FFPopSim.haploid_highd__get_fixed_mutations(self)

    def _get_number_of_mutations(self):
        """_get_number_of_mutations(haploid_highd self) -> _intVector"""
        return _FFPopSim.haploid_highd__get_number_of_mutations(self)

    def set_allele_frequencies(self, *args, **kwargs):
        """
        Initialize the population according to the given allele frequencies in linkage equilibrium.

        Parameters:
           - frequencies: an array of length L with all allele frequencies
           - N: set the population size and, if still unset, the carrying
             capacity to this value

        """
        if len(args) and (len(args[0]) != self.L):
            raise ValueError('Please input an L dimensional list of allele frequencies.')


        val = _FFPopSim.haploid_highd_set_allele_frequencies(self, *args, **kwargs)
        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    def set_wildtype(self, *args, **kwargs):
        """
        Initialize a population of wildtype individuals

        Parameters:
           - N: the number of individuals

        .. note:: the carrying capacity is set to the same value if still unset.

        """
        val = _FFPopSim.haploid_highd_set_wildtype(self, *args, **kwargs)
        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    def track_locus_genealogy(self, *args, **kwargs):
        """
        Track the genealogy of some loci.

        Parameters:
           - loci: sites whose genealogy is being stored

        Returns:
           - zero if successful

        """
        return _FFPopSim.haploid_highd_track_locus_genealogy(self, *args, **kwargs)

    def add_genotype(self, *args, **kwargs):
        """
        Add new individuals to the population with certain genotypes

        Parameters:
           - genotype: genotype to add to the population (Boolean list)
           - n: number of new individuals carrying that genotype

        """
        val = _FFPopSim.haploid_highd_add_genotype(self, *args, **kwargs)
        self._nonempty_clones = _np.array(self._get_nonempty_clones())


        return val

    def add_trait_coefficient(self, *args, **kwargs):
        """
        Add a coefficient to the trait landscape.
         
        Parameters:
           - value: value of the coefficient
           - loci: array/list of loci indexed by the coefficient.
           - t: number of the trait to be changed

        **Example**: to set a second-order epistatic term :math:`t_{ij} = 0.1`, use ``add_trait_coefficient(0.1, [i, j])``.

        .. warning:: the -/+ basis is used throughout the library. If you are used to the 0/1 basis, keep in mind that the interaction series-expansion is different.

        """
        return _FFPopSim.haploid_highd_add_trait_coefficient(self, *args, **kwargs)

    def clear_trait(self, t=0):
        """
        Clear a trait landscape.

        Parameters:
           - t: number of the trait to be cleared

        """
        return _FFPopSim.haploid_highd_clear_trait(self, t)

    def clear_traits(self):
        """Clear all trait landscapes"""
        return _FFPopSim.haploid_highd_clear_traits(self)

    def set_random_trait_epistasis(self, *args, **kwargs):
        """
        Set a random epistatic term in the genotype-phenotype map. This is meant as an approximation to multi-locus epistasis to which many locus sets contribute. It assigns to each genotype a reprodrucible fitness component drawn from a Gaussian distribution.

        Parameters:
           - epistasis_std: standard deviation of the random epistatic terms
           - t: trait number

        .. note:: the epistatic terms will be Gaussian distributed around zero with the given standard deviation.

        """
        return _FFPopSim.haploid_highd_set_random_trait_epistasis(self, *args, **kwargs)

    def add_fitness_coefficient(self, *args, **kwargs):
        """Shortcut for add_trait_coefficient when there is only one trait"""
        return _FFPopSim.haploid_highd_add_fitness_coefficient(self, *args, **kwargs)

    def clear_fitness(self):
        """Shortcut for clear_trait when there is only one trait"""
        return _FFPopSim.haploid_highd_clear_fitness(self)

    def set_random_epistasis(self, *args, **kwargs):
        """Shortcut for set_random_trait_epistasis when there is only one trait"""
        return _FFPopSim.haploid_highd_set_random_epistasis(self, *args, **kwargs)

    def evolve(self, gen=1):
        """
        Evolve for some generations.

        Parameters:
           - gen: number of generations, defaults to one

        """
        val = _FFPopSim.haploid_highd_evolve(self, gen)
        self.calc_stat()
        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    def bottleneck(self, *args, **kwargs):
        """
        Make the population undergo a bottleneck

        Parameters:
           - size_of_bottleneck: the number of individuals at the bottleneck

        """
        val = _FFPopSim.haploid_highd_bottleneck(self, *args, **kwargs)
        self.calc_stat()
        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    def flip_single_locus(self, *args, **kwargs):
        """
        Take a random clone, flip the allele at the selected locus and create a new clone.

        Parameters:
           - locus: locus to flip

        Returns:
           - index: index of the new clone with the flipped locus

        """
        return _FFPopSim.haploid_highd_flip_single_locus(self, *args, **kwargs)

    def calc_stat(self):
        """Calculate trait and fitness statistics for the population"""
        return _FFPopSim.haploid_highd_calc_stat(self)

    def unique_clones(self):
        """
        Recompress the clone structure

        During its evolution, identical clones might be generated by different routes at
        different times. This function merges any such duplicates into unique clones with
        the size equal to the sum of the sizes of the duplicates.

        """
        return _FFPopSim.haploid_highd_unique_clones(self)

    def _get_nonempty_clones(self):
        """_get_nonempty_clones(haploid_highd self) -> _intVector"""
        return _FFPopSim.haploid_highd__get_nonempty_clones(self)

    def random_clone(self):
        """
        Get a random clone

        Returns:
           - clone: index of the random clone

        """
        val = _FFPopSim.haploid_highd_random_clone(self)
        val = (self._nonempty_clones == val).nonzero()[0][0]


        return val

    def get_diversity_statistics(self, n_sample=1000):
        """
        Get the mean and variance of the diversity in the population.

        Parameters:
           - n_sample: number of individuals to sample at random from the population

        Returns:
           - stat: structure with mean and variance of diversity in the population

        """
        return _FFPopSim.haploid_highd_get_diversity_statistics(self, n_sample)

    def get_divergence_statistics(self, n_sample=1000):
        """
        Get the mean and variance of the divergence in the population.

        Parameters:
           - n_sample: number of individuals to sample at random from the population

        Returns:
           - stat: structure with mean and variance of divergence in the population

        """
        return _FFPopSim.haploid_highd_get_divergence_statistics(self, n_sample)

    def get_allele_frequency(self, *args, **kwargs):
        """
        Get the frequency of the + allele at the selected locus

        Parameters:
           - locus: locus whose frequency of the + allele is to be returned

        Returns:
           - frequency: allele frequency in the population

        """
        return _FFPopSim.haploid_highd_get_allele_frequency(self, *args, **kwargs)

    def get_derived_allele_frequency(self, *args, **kwargs):
        """
        Get the frequency of the derived allele at the selected locus

        Parameters:
           - locus: locus whose frequency of the derived allele is to be returned

        Returns:
           - frequency: allele frequency in the population

        """
        return _FFPopSim.haploid_highd_get_derived_allele_frequency(self, *args, **kwargs)

    def get_pair_frequency(self, *args, **kwargs):
        """
        Get the joint frequency of two + alleles

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the joint frequency of the + alleles

        """
        return _FFPopSim.haploid_highd_get_pair_frequency(self, *args, **kwargs)

    def get_chi(self, *args, **kwargs):
        """
        Get :math:`\chi_i` of an allele

        Parameters:
            - locus: locus whose chi is to be computed

        Returns:
            - the chi of that allele, :math:`\chi_i := \left<s_i\right>`, where :math:`s_i \in \{\pm1\}`.

        """
        return _FFPopSim.haploid_highd_get_chi(self, *args, **kwargs)

    def get_derived_chi(self, *args, **kwargs):
        """
        Get :math:`\chi_i` of a derived allele

        Parameters:
            - locus: locus whose chi is to be computed

        Returns:
            - the chi of that derived allele, :math:`\chi_i := \left<s_i\right>`, where :math:`s_i \in \{\pm1\}`.

        """
        return _FFPopSim.haploid_highd_get_derived_chi(self, *args, **kwargs)

    def get_chi2(self, *args, **kwargs):
        """
        Get :math:`\chi_{ij}`

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`\chi_{ij} := \left<s_i s_j\right> - \chi_i \cdot \chi_j`.

        """
        return _FFPopSim.haploid_highd_get_chi2(self, *args, **kwargs)

    def get_LD(self, *args, **kwargs):
        """
        Get linkage disequilibrium

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`LD := 1 / 4 \left[\left<s_i s_j\right> - \chi_i \cdot \chi_j\right]`.

        """
        return _FFPopSim.haploid_highd_get_LD(self, *args, **kwargs)

    def get_moment(self, *args, **kwargs):
        """
        Get moment of two alleles in the -/+ basis

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the second moment, i.e. :math:`\left<s_i s_j\right>`, where :math:`s_i, s_j \in \{-1, 1\}`.

        """
        return _FFPopSim.haploid_highd_get_moment(self, *args, **kwargs)

    def get_trait_weight(self, *args, **kwargs):
        """get_trait_weight(haploid_highd self, int t) -> double"""
        return _FFPopSim.haploid_highd_get_trait_weight(self, *args, **kwargs)

    def get_fitness(self, *args, **kwargs):
        """
        Get the fitness of an individual

        Parameters:
           - n: index of the clone whose fitness is to be computed

        Returns:
           - fitness: fitness value of that clone

        """
        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_fitness(self, *args, **kwargs)

    def get_clone_size(self, *args, **kwargs):
        """
        Get the size of a clone

        Parameters:
           - n: index of the clone

        Returns:
           - size: size of the selected clone

        """
        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_clone_size(self, *args, **kwargs)

    def get_trait(self, *args, **kwargs):
        """
        Get a trait of an individual

        Parameters:
           - n: index of the clone whose trait is to be computed
           - t: trait to be computed

        Returns:
           - trait: value of that trait for that clone

        """
        if (len(args) > 1) and (args[1] >= self.number_of_traits):
            raise ValueError("There are only "+str(self.number_of_traits)+" traits.")
        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_trait(self, *args, **kwargs)

    def get_trait_epistasis(self, t=0):
        """
        Get the epistatic terms of the genotype/phenotype map of the chosen trait.

        Parameters:
           - t: trait number

        Returns:
           - coefficients: tuple of coefficients, with a value and a tuple of loci

        .. note:: This function is designed to work well in conjunction with add_trait_coefficient.

        """
        return _FFPopSim.haploid_highd_get_trait_epistasis(self, t)

    def get_fitness_statistics(self):
        """
        Get the mean and variance of the fitness in the population.

        Returns:
           - stat: structure with mean and variance of the fitness in the population

        """
        return _FFPopSim.haploid_highd_get_fitness_statistics(self)

    def get_trait_statistics(self, t=0):
        """
        Get the mean and variance of a trait in the population.

        Parameters:
           - t: number of the trait whose statistics are to be computed

        Returns:
           - stat: structure with mean and variance of the trait in the population

        """
        return _FFPopSim.haploid_highd_get_trait_statistics(self, t)

    def get_trait_covariance(self, *args, **kwargs):
        """
        Get the covariance of two traits in the population.

        Parameters:
           - t1: first trait
           - t2: second trait

        Returns:
           - cov: the covariance of the two traits

        """
        return _FFPopSim.haploid_highd_get_trait_covariance(self, *args, **kwargs)

    def _update_traits(self):
        """_update_traits(haploid_highd self)"""
        return _FFPopSim.haploid_highd__update_traits(self)

    def _update_fitness(self):
        """_update_fitness(haploid_highd self)"""
        return _FFPopSim.haploid_highd__update_fitness(self)

    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.haploid_highd___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.haploid_highd___repr__(self)

    @property
    def mutation_rate(self):
       '''mutation rate (per site per generation)'''
       return self._get_mutation_rate()

    @mutation_rate.setter
    def mutation_rate(self, m):
        if self.all_polymorphic:
            raise ValueError("You cannot set all_polymorphic and a nonzero mutation rate.")
        else:
            self._set_mutation_rate(m)

    def get_clone(self, *args, **kwargs):
        """
        Get a single clone

        Parameters:
           - n: index of the clone

        Returns:
           - clone: the n-th clone in the population

        """
        return _FFPopSim.haploid_highd_get_clone(self, *args, **kwargs)

    L = _swig_property(_FFPopSim.haploid_highd_L_get)
    number_of_loci = _swig_property(_FFPopSim.haploid_highd_number_of_loci_get)
    N = _swig_property(_FFPopSim.haploid_highd_N_get)
    population_size = _swig_property(_FFPopSim.haploid_highd_population_size_get)
    generation = _swig_property(_FFPopSim.haploid_highd_generation_get, _FFPopSim.haploid_highd_generation_set)
    number_of_clones = _swig_property(_FFPopSim.haploid_highd_number_of_clones_get)
    number_of_traits = _swig_property(_FFPopSim.haploid_highd_number_of_traits_get)
    max_fitness = _swig_property(_FFPopSim.haploid_highd_max_fitness_get)
    participation_ratio = _swig_property(_FFPopSim.haploid_highd_participation_ratio_get)
    all_polymorphic = _swig_property(_FFPopSim.haploid_highd_all_polymorphic_get)
    @property
    def polymorphisms(self):
        '''Polymorphisms from all_polymorphic (read-only)'''
        if not self.all_polymorphic:
            raise ValueError("all_polymorphic is not set.")
        return self._get_polymorphisms()


    @property
    def fixed_mutations(self):
        '''Fixed mutations from all_polymorphic (read-only)'''
        if not self.all_polymorphic:
            raise ValueError("all_polymorphic is not set.")
        return self._get_fixed_mutations()


    @property
    def number_of_mutations(self):
        '''Fixed mutations from all_polymorphic (read-only)'''
        if not self.all_polymorphic:
            raise ValueError("all_polymorphic is not set.")
        return self._get_number_of_mutations()

    def _set_trait_weights(self, *args, **kwargs):
        """_set_trait_weights(haploid_highd self, double * IN_ARRAY1)"""
        if len(args) and (len(args[0]) != self.number_of_traits):
            raise ValueError('The weights must be a sequence of length equal to the number of traits.')


        return _FFPopSim.haploid_highd__set_trait_weights(self, *args, **kwargs)

    def _get_trait_weights(self, *args, **kwargs):
        """
        weight of each trait on fitness

        .. note:: Fitness is updated automatically when the weights are changed.

        """
        args = tuple(list(args) + [self.number_of_traits])


        return _FFPopSim.haploid_highd__get_trait_weights(self, *args, **kwargs)

    trait_weights = property(_get_trait_weights, _set_trait_weights)

    def copy(self, rng_seed=0):
        '''Copy population into new instance.
        
        Parameters:
           - rng_seed: random number to initialize the new population
        '''
        pop = haploid_highd(self.L, rng_seed=rng_seed, number_of_traits=self.number_of_traits)

        
        pop.recombination_model =  self.recombination_model
        pop.outcrossing_rate = self.outcrossing_rate
        pop.crossover_rate = self.crossover_rate
        pop.mutation_rate = self.mutation_rate
        pop.circular = self.circular

        
        for i in xrange(self.number_of_traits):
            pop.set_trait_additive(self.get_trait_additive(i), i)
            for coeff in self.get_trait_epistasis(i):
                pop.add_trait_coefficient(coeff[0], coeff[1], i)

        
        pop.carrying_capacity = self.carrying_capacity
        pop.set_genotypes(self.get_genotypes(), self.get_clone_sizes())    

        
        pop.generation = self.generation
        
        return pop

    def status(self):
        '''Print a status list of the population parameters'''
        parameters = (('number of loci', 'L'),
                      ('circular', 'circular'),
                      ('number of traits', 'number_of_traits'),
                      ('population size', 'N'),
                      ('carrying capacity', 'carrying_capacity'),
                      ('generation', 'generation'),
                      ('outcrossing rate', 'outcrossing_rate'),
                      ('crossover rate', 'crossover_rate'),
                      ('recombination model', 'recombination_model'),
                      ('mutation rate', 'mutation_rate'),
                      ('participation ratio', 'participation_ratio'),
                      ('number of non-empty clones', 'number_of_clones'),
                     )
        lenmax = max(map(lambda x: len(x[0]), parameters))

        for (strin, name) in parameters:
            par = getattr(self, name)
            
            
            if strin == 'recombination model':
                if par == 0:
                    par = 'FREE_RECOMBINATION'
                else:
                    par = 'CROSSOVERS'
            print ('{:<'+str(lenmax + 2)+'s}').format(strin)+'\t'+str(par)

    def set_genotypes(self, *args, **kwargs):
        """
        Initialize population with fixed counts for specific genotypes.

        Parameters:
           - genotypes: list of genotypes to set. Genotypes are lists of alleles,
             e.g. [[0,0,1,0], [0,1,1,1]] for genotypes 0010 and 0111   
           - counts: list of the number at which each of those genotypes it to be present

        .. note:: the population size and, if unset, the carrying capacity will be set
                  as the sum of the counts.

        **Example**: if you want to initialize 200 individuals with genotype 001 and
                     300 individuals with genotype 110, you can use
                     ``set_genotypes([[0,0,1], [1,1,0]], [200, 300])``

        """
        if len(args) and (len(args) >= 2):
            genotypes = args[0]
            counts = args[1]
            genotypes = _np.array(genotypes, float, copy=False, ndmin=2)
            counts = _np.asarray(counts, float)
            if len(genotypes) != len(counts):
                raise ValueError('Genotypes and counts must have the same length')
            args = tuple([genotypes.ravel(), counts] + list(args[2:]))


        val = _FFPopSim.haploid_highd_set_genotypes(self, *args, **kwargs)
        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    def _get_genealogy(self):
        """
        Genealogy of the tracked loci.

        .. note:: This attribute is read-only.

        """
        return _FFPopSim.haploid_highd__get_genealogy(self)

    genealogy = property(_get_genealogy)

    def get_allele_frequencies(self, *args, **kwargs):
        """Get all allele frequencies"""
        args = tuple(list(args) + [self.L])


        return _FFPopSim.haploid_highd_get_allele_frequencies(self, *args, **kwargs)

    def get_derived_allele_frequencies(self, *args, **kwargs):
        """Get all derived allele frequencies"""
        args = tuple(list(args) + [self.L])


        return _FFPopSim.haploid_highd_get_derived_allele_frequencies(self, *args, **kwargs)

    def get_trait_additive(self, *args, **kwargs):
        """
        Get an array with the additive coefficients of all loci of a trait. 

        Parameters:
           - t: number of the trait

        Returns:
           - coefficients: array of additive coefficients for the selected trait

        """
        if (len(args) > 1) and (args[1] >= self.number_of_traits):
            raise ValueError("There are only "+str(self.number_of_traits)+" traits.")
        args = tuple([self.L] + list(args))


        return _FFPopSim.haploid_highd_get_trait_additive(self, *args, **kwargs)

    def set_trait_additive(self, *args, **kwargs):
        """
        Set the additive part of a trait

        Parameters:
           - coefficients: array of coefficients for the trait (of length L). All previous additive coefficents are erased
           - t: number of the trait to set

        """
        if (len(args) > 1) and (args[1] >= self.number_of_traits):
            raise ValueError("There are only "+str(self.number_of_traits)+" traits.")
        if len(args) and (len(args[0]) != self.L):
            raise ValueError("L coefficients expected.")


        return _FFPopSim.haploid_highd_set_trait_additive(self, *args, **kwargs)

    def set_fitness_additive(self, *args, **kwargs):
        """Shortcut for set_trait_additive when there is only one trait"""
        if len(args) and (len(args[0]) != self.L):
            raise ValueError("L coefficients expected.")


        return _FFPopSim.haploid_highd_set_fitness_additive(self, *args, **kwargs)

    def get_fitnesses(self):
        '''Get the fitness of all clones.'''
        f = _np.zeros(self.number_of_clones)
        for i in xrange(self.number_of_clones):
            f[i] = self.get_fitness(i)
        return f

    def get_traits(self):
        '''Get all traits from all clones'''
        t = _np.zeros((self.number_of_clones, self.number_of_traits))
        for i in xrange(self.number_of_clones):
            for j in xrange(self.number_of_traits):
                t[i, j] = self.get_trait(i, j)
        return t

    def get_clone_sizes(self):
        '''Get the size of all clones.'''
        s = _np.zeros(self.number_of_clones, int)
        for i in xrange(self.number_of_clones):
            s[i] = self.get_clone_size(i)
        return s

    def get_genotype(self, *args, **kwargs):
        """get_genotype(haploid_highd self, int n) -> boost::dynamic_bitset< >"""
        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_genotype(self, *args, **kwargs)

    def get_genotypes(self):
        '''Get all genotypes of the population.

        Return:
           - genotypes: boolean 2D array with the genotypes

        .. note:: this function does not return the sizes of each clone.
        '''
        genotypes = _np.zeros((self.number_of_clones, self.number_of_loci), bool)
        for i in xrange(self.number_of_clones):
            genotypes[i] = self.get_genotype(i)
        return genotypes

    def distance_Hamming(self, clone_gt1, clone_gt2, chunks=None, every=1):
        '''Calculate the Hamming distance between two genotypes

        Parameters:
           - clone_gt1: index of the clone corresponding to the first genotype
           - clone_gt2: index of the clone corresponding to the second genotype
           - chunks: list of pairs delimiting the genetic areas to include
           - every: do the comparison only on certain sites

        **Example**: to calculate the distance between the first two clones
        limited to third codon positions between locus 90 and 200, use:
        ``distance_Hamming(0, 1, chunks=[92, 200], every=3)``.
        '''
        if _np.isscalar(clone_gt1):
            genotypes = self.get_genotypes((clone_gt1, clone_gt2))
            clone_gt1 = genotypes[0]
            clone_gt2 = genotypes[1]

        if chunks is not None:
            ind = _np.zeros(clones.shape[1], bool)
            for chunk in chunks:
                inde = _np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            clone_gt1 = clone_gt1[ind]
            clone_gt2 = clone_gt2[ind]
        return (clone_gt1 != clone_gt2).sum()

    def random_genomes(self, n):
        '''Get a sample of random genomes from the population

        Parameters:
           - n: number of random genomes to compute

        Returns:
           - gts: (n x L) bool matrix with the n genotypes
        '''

        L = self.number_of_loci
        genotypes = _np.zeros((n, L), bool)
        for i in xrange(genotypes.shape[0]):
            genotypes[i] = self.get_genotype(self.random_clone())
        return genotypes

    def random_clones(self, n):
        '''Get random clones
        
        Parameters:
           - n: number of random clones to return
        
        Returns:
           - clones: clone indices
        '''
        return _np.array([self.random_clone() for i in xrange(n)], int)

    def get_fitness_histogram(self, n_sample=1000, **kwargs):
        '''Calculate the fitness histogram of a population sample.

        Parameters:
           - n_sample: number of individuals to sample

        Returns:
           - h: numpy.histogram of fitness in the population
        '''

        fit = [self.get_fitness(self.random_clone()) for i in xrange(n_sample)]
        h = _np.histogram(fit, **kwargs)
        return h
        
        
    def plot_fitness_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot a distribution of fitness of a population sample.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist

        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        fit = [self.get_fitness(self.random_clone()) for i in xrange(n_sample)]
        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Fitness histogram')
            axis.set_xlabel('Fitness')
        return axis.hist(fit, **kwargs)
        
        
    def get_divergence_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
        '''Get the divergence histogram restricted to those chunks of the genome.

        Parameters:
           - bins: number or array of bins to be used in the histogram (see also numpy.histogram)
           - chunks: restrict analysis to some chunk in the genome. It must be an n x 2 matrix with
                     the initial and (final+1) positions of the chunks
           - every: restrict analysis to every X positions. For instance, if every third site is neutral,
                    this argument can be used to only look at those neutral sites
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to numpy.histogram

        Returns:
           - h: numpy.histogram of divergence in the population
        '''

        
        if chunks is not None:
            chunks = _np.asarray(chunks)
            if (_np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')
        
        
        genotypes = self.random_genomes(n_sample)
        
        
        if chunks is not None:
            ind = _np.zeros(genotypes.shape[1], bool)
            for chunk in chunks:
                inde = _np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            genotypes = genotypes[:,ind]
        
        
        div = genotypes.sum(axis=1)
        
        
        return _np.histogram(div, bins=bins, **kwargs)
        
        
    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the divergence histogram of a population sample.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist
        
        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        genotypes = self.random_genomes(n_sample)
        div = genotypes.sum(axis=1)
         
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Divergence histogram')
            axis.set_xlabel('Divergence')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        return axis.hist(div, **kwargs)
        
        
    def get_diversity_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
        '''Get the diversity histogram restricted to those chunks of the genome.

        Parameters:
           - bins: number or array of bins to be used in the histogram (see also numpy.histogram)
           - chunks: restrict analysis to some chunk in the genome. It must be an n x 2 matrix with
                     the initial and (final+1) positions of the chunks
           - every: restrict analysis to every X positions. For instance, if every third site is neutral,
                    this argument can be used to only look at those neutral sites
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to numpy.histogram

        Returns:
           - h: numpy.histogram of diversity in the population
        '''

        
        if chunks is not None:
            chunks = _np.asarray(chunks)
            if (_np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')
        
        
        genotypes = self.random_genomes(2 * n_sample)
        
        
        if chunks is not None:
            ind = _np.zeros(genotypes.shape[1], bool)
            for chunk in chunks:
                inde = _np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            genotypes = genotypes[:,ind]
        
        
        genotypes1 = genotypes[:genotypes.shape[0] / 2]
        genotypes2 = genotypes[-genotypes1.shape[0]:]
        div = (genotypes1 != genotypes2).sum(axis=1)
        
        
        return _np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the diversity histogram of a population sample.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist
        
        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        genotypes1 = self.random_genomes(n_sample)
        genotypes2 = self.random_genomes(n_sample)
        div = (genotypes1 != genotypes2).sum(axis=1)
        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Diversity histogram')
            axis.set_xlabel('Diversity')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        return axis.hist(div, **kwargs)

haploid_highd._get_mutation_rate = new_instancemethod(_FFPopSim.haploid_highd__get_mutation_rate,None,haploid_highd)
haploid_highd._set_mutation_rate = new_instancemethod(_FFPopSim.haploid_highd__set_mutation_rate,None,haploid_highd)
haploid_highd._get_polymorphisms = new_instancemethod(_FFPopSim.haploid_highd__get_polymorphisms,None,haploid_highd)
haploid_highd._get_fixed_mutations = new_instancemethod(_FFPopSim.haploid_highd__get_fixed_mutations,None,haploid_highd)
haploid_highd._get_number_of_mutations = new_instancemethod(_FFPopSim.haploid_highd__get_number_of_mutations,None,haploid_highd)
haploid_highd.track_locus_genealogy = new_instancemethod(_FFPopSim.haploid_highd_track_locus_genealogy,None,haploid_highd)
haploid_highd.add_trait_coefficient = new_instancemethod(_FFPopSim.haploid_highd_add_trait_coefficient,None,haploid_highd)
haploid_highd.clear_trait = new_instancemethod(_FFPopSim.haploid_highd_clear_trait,None,haploid_highd)
haploid_highd.clear_traits = new_instancemethod(_FFPopSim.haploid_highd_clear_traits,None,haploid_highd)
haploid_highd.set_random_trait_epistasis = new_instancemethod(_FFPopSim.haploid_highd_set_random_trait_epistasis,None,haploid_highd)
haploid_highd.add_fitness_coefficient = new_instancemethod(_FFPopSim.haploid_highd_add_fitness_coefficient,None,haploid_highd)
haploid_highd.clear_fitness = new_instancemethod(_FFPopSim.haploid_highd_clear_fitness,None,haploid_highd)
haploid_highd.set_random_epistasis = new_instancemethod(_FFPopSim.haploid_highd_set_random_epistasis,None,haploid_highd)
haploid_highd.flip_single_locus = new_instancemethod(_FFPopSim.haploid_highd_flip_single_locus,None,haploid_highd)
haploid_highd.calc_stat = new_instancemethod(_FFPopSim.haploid_highd_calc_stat,None,haploid_highd)
haploid_highd.unique_clones = new_instancemethod(_FFPopSim.haploid_highd_unique_clones,None,haploid_highd)
haploid_highd._get_nonempty_clones = new_instancemethod(_FFPopSim.haploid_highd__get_nonempty_clones,None,haploid_highd)
haploid_highd.get_diversity_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_diversity_statistics,None,haploid_highd)
haploid_highd.get_divergence_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_divergence_statistics,None,haploid_highd)
haploid_highd.get_allele_frequency = new_instancemethod(_FFPopSim.haploid_highd_get_allele_frequency,None,haploid_highd)
haploid_highd.get_derived_allele_frequency = new_instancemethod(_FFPopSim.haploid_highd_get_derived_allele_frequency,None,haploid_highd)
haploid_highd.get_pair_frequency = new_instancemethod(_FFPopSim.haploid_highd_get_pair_frequency,None,haploid_highd)
haploid_highd.get_chi = new_instancemethod(_FFPopSim.haploid_highd_get_chi,None,haploid_highd)
haploid_highd.get_derived_chi = new_instancemethod(_FFPopSim.haploid_highd_get_derived_chi,None,haploid_highd)
haploid_highd.get_chi2 = new_instancemethod(_FFPopSim.haploid_highd_get_chi2,None,haploid_highd)
haploid_highd.get_LD = new_instancemethod(_FFPopSim.haploid_highd_get_LD,None,haploid_highd)
haploid_highd.get_moment = new_instancemethod(_FFPopSim.haploid_highd_get_moment,None,haploid_highd)
haploid_highd.get_trait_weight = new_instancemethod(_FFPopSim.haploid_highd_get_trait_weight,None,haploid_highd)
haploid_highd.get_trait_epistasis = new_instancemethod(_FFPopSim.haploid_highd_get_trait_epistasis,None,haploid_highd)
haploid_highd.get_fitness_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_fitness_statistics,None,haploid_highd)
haploid_highd.get_trait_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_trait_statistics,None,haploid_highd)
haploid_highd.get_trait_covariance = new_instancemethod(_FFPopSim.haploid_highd_get_trait_covariance,None,haploid_highd)
haploid_highd._update_traits = new_instancemethod(_FFPopSim.haploid_highd__update_traits,None,haploid_highd)
haploid_highd._update_fitness = new_instancemethod(_FFPopSim.haploid_highd__update_fitness,None,haploid_highd)
haploid_highd.__str__ = new_instancemethod(_FFPopSim.haploid_highd___str__,None,haploid_highd)
haploid_highd.__repr__ = new_instancemethod(_FFPopSim.haploid_highd___repr__,None,haploid_highd)
haploid_highd.get_clone = new_instancemethod(_FFPopSim.haploid_highd_get_clone,None,haploid_highd)
haploid_highd._get_genealogy = new_instancemethod(_FFPopSim.haploid_highd__get_genealogy,None,haploid_highd)
haploid_highd_swigregister = _FFPopSim.haploid_highd_swigregister
haploid_highd_swigregister(haploid_highd)

HIVPOP_VERBOSE = _FFPopSim.HIVPOP_VERBOSE
HIVPOP_BADARG = _FFPopSim.HIVPOP_BADARG
NOTHING = _FFPopSim.NOTHING
HIVGENOME = _FFPopSim.HIVGENOME
ENV_START = _FFPopSim.ENV_START
ENV_END = _FFPopSim.ENV_END
class hivgene(object):
    """Structure for an HIV gene."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    start = _swig_property(_FFPopSim.hivgene_start_get, _FFPopSim.hivgene_start_set)
    end = _swig_property(_FFPopSim.hivgene_end_get, _FFPopSim.hivgene_end_set)
    def __init__(self, start_in=0, end_in=10000): 
        """Structure for an HIV gene."""
        _FFPopSim.hivgene_swiginit(self,_FFPopSim.new_hivgene(start_in, end_in))
    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.hivgene___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.hivgene___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_hivgene
hivgene.__str__ = new_instancemethod(_FFPopSim.hivgene___str__,None,hivgene)
hivgene.__repr__ = new_instancemethod(_FFPopSim.hivgene___repr__,None,hivgene)
hivgene_swigregister = _FFPopSim.hivgene_swigregister
hivgene_swigregister(hivgene)

class hivpopulation(haploid_highd):
    """
    Class for HIV population genetics (genome size = 10000).

    This class is the main object for simulating the evolution of HIV.
    The class offers a number of functions, but an example will explain the basic
    idea::

       #####################################
       #   EXAMPLE SCRIPT                  #
       #####################################
       import numpy as np
       import matplotlib.pyplot as plt
       import FFPopSim as h
       
       c = h.hivpopulation(2000)        # Create a population of 2000 individuals
       c.evolve(100)                    # Evolve (neutrally) for 100 generations
       c.plot_divergence_histogram()
       plt.show()
       #####################################

    **This class is a subclass of haploid_high and offers most of its methods.**
    In addition to the haploid_highd class, this class offers functions for reading
    fitness and drug resistance landscapes from a text file, and to save genomes as
    plain text or in compressed NumPy format.

    Moreover, there are two phenotypic traits, replication and resistance. Their
    relative importance for viral fitness is set by the ``treatment`` attribute::

       f[trait] = trait[0] + treatment * trait[1]

    By default, ``treatment`` is set to zero, to simulate non-treated patients.

    The gene structure of HIV is not modelled explicitely, except for a stub of
    1000 sites between position 7000 and 8000 to roughly model the _env_ gene.

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, N=0, rng_seed=0, mutation_rate=3e-5, coinfection_rate=1e-2, crossover_rate=1e-3): 
        """
        Construct a HIV population with certain parameters.

        Parameters:

           - N     number of viral particles
           - rng_seed	seed for the random number generator. If this is 0, time(NULL)+getpid() is used.
           - mutation_rate	mutation rate in events / generation / site
           - coinfection_rate	probability of coinfection of the same cell by two viral particles in events / generation
           - crossover_rate	probability of template switching during coinfection in events / site

        .. note:: the genome length is 10000 (see HIVGENOME).

        """
        _FFPopSim.hivpopulation_swiginit(self,_FFPopSim.new_hivpopulation(N, rng_seed, mutation_rate, coinfection_rate, crossover_rate))
    __swig_destroy__ = _FFPopSim.delete_hivpopulation
    env = _swig_property(_FFPopSim.hivpopulation_env_get, _FFPopSim.hivpopulation_env_set)
    def read_replication_coefficients(self, *args, **kwargs):
        """
        Read replication coefficients from a text file

        Parameters:
           - filename: string with the name of the file to read the coefficients from

        """
        return _FFPopSim.hivpopulation_read_replication_coefficients(self, *args, **kwargs)

    def read_resistance_coefficients(self, *args, **kwargs):
        """
        Read resistance coefficients from a text file

        Parameters:
           - filename: string with the name of the file to read the coefficients from

        """
        return _FFPopSim.hivpopulation_read_resistance_coefficients(self, *args, **kwargs)

    def write_genotypes(self, *args, **kwargs):
        """
        Store random genotypes into a plain text file.

        Parameters:
           - filename: string with the name of the file to store the genotype into
           - sample_size: how many random genotypes to store
           - gt_label: common fasta label for the genotypes (e.g. 'HIV-sim')
           - start: if only a portion of the genome is to be stored, start from this position
           - length: store a chunk from ``start`` to this length

        """
        return _FFPopSim.hivpopulation_write_genotypes(self, *args, **kwargs)

    def __str__(self):
        """x.__str__() <==> str(x)"""
        return _FFPopSim.hivpopulation___str__(self)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return _FFPopSim.hivpopulation___repr__(self)

    def copy(self, rng_seed=0):
        '''Copy population into new instance.
        
        Parameters:
           - rng_seed: random number to initialize the new population
        '''
        pop = hivpopulation(self.N,
                            rng_seed=rng_seed,
                            mutation_rate=self.mutation_rate,
                            coinfection_rate=self.outcrossing_rate,
                            crossover_rate=self.crossover_rate)

        
        for i in xrange(self.number_of_traits):
            pop.set_trait_additive(self.get_trait_additive(i), i)
            for coeff in self.get_trait_epistasis(i):
                pop.add_trait_coefficient(coeff[0], coeff[1], i)

        
        pop.carrying_capacity = self.carrying_capacity
        pop.set_genotypes(self.get_genotypes(), self.get_clone_sizes())    

        
        pop._set_generation(self.generation)
        
        return pop

    treatment = _swig_property(_FFPopSim.hivpopulation_treatment_get, _FFPopSim.hivpopulation_treatment_set)
    def write_genotypes_compressed(self, filename, sample_size, gt_label='', start=0, length=0):
        '''Store random genotypes into a compressed file.

        Parameters:
           - filename: string with the name of the file to store the genotype into
           - sample_size: how many random genotypes to store
           - gt_label: common fasta label for the genotypes (e.g. "HIV-sim")
           - start: if only a portion of the genome is to be stored, start from this position
           - length: store a chunk from ``start`` to this length

        The genotypes can be read using numpy.load.
        '''

        import numpy as np 
        L = self.number_of_loci
        if length <= 0:
            length = L - start
        d = {}
        for i in xrange(sample_size):
            rcl = self.random_clone()
            d['>'+str(i)+'_GT-'+gt_label+'_'+str(rcl)] = self.get_genotype(rcl)[start:start+length]
        np.savez_compressed(filename, **d)    

    def set_trait_landscape(self,
                            traitnumber=0,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set HIV trait landscape according to some general parameters.

        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.
        
        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        import numpy as np
        
        
        self.clear_trait(traitnumber)

        
        L = self.L
        aL = np.arange(L)

        
        
        
        
        
        
        onetwo_vector = (aL % 3) < 2
        random_numbers = np.random.random(L)
        adaptive_mutations = (random_numbers > (1 - adaptive_fraction)) & onetwo_vector
        lethal_mutations = (random_numbers < lethal_fraction) & onetwo_vector
        deleterious_mutations = ((random_numbers > lethal_fraction) & \
                                 (random_numbers < (lethal_fraction + deleterious_fraction)) & \
                                 (random_numbers < (1 - adaptive_fraction)) & \
                                 onetwo_vector)
        
        
        single_locus_effects=np.zeros(L)
        single_locus_effects[np.where(deleterious_mutations)] = -np.random.exponential(effect_size_deleterious, deleterious_mutations.sum())
        single_locus_effects[np.where(adaptive_mutations)] = np.random.exponential(effect_size_adaptive, adaptive_mutations.sum())
        single_locus_effects[np.where(lethal_mutations)] = -effect_size_lethal
        
        
        env_position = (aL >= self.env.start) & (aL < self.env.end)
        env_mutations = (random_numbers > (1 - env_fraction)) & onetwo_vector & env_position
        single_locus_effects[np.where(env_mutations)] = np.random.exponential(effect_size_env, env_mutations.sum())
            
        
        self.set_trait_additive(single_locus_effects, traitnumber)

        
        multi_locus_coefficients=[]
        def add_epitope(strength=0.2):
            '''Note: we are in the +-1 basis.'''
            loci = random.sample(range(9),2)
            loci.sort()
            depression = - 0.05
            f1 = depression*0.25
            f2 = depression*0.25
            f12 = depression*0.25 - strength*0.5
            return loci, f1,f2,f12
         
        def add_valley(depth=0.1, height=0.01):
            '''Note: we are in the +-1 basis.'''
            f1 = height*0.25
            f2 = height*0.25
            f12 = height*0.25 + depth*0.5
            return (f1,f2,f12)

        
        for vi in xrange(number_valleys):
            pos = np.random.random_integers(L/3-100)
            d = int(np.random.exponential(10) + 1)
            valley_str = np.random.exponential(valley_strength)
            if number_valleys:
                print 'valley:', pos*3, valley_str
            (f1,f2,f12)=add_valley(valley_str)
            single_locus_effects[pos*3+1]+=f1
            single_locus_effects[(pos+d)*3+1]+=f2
            multi_locus_coefficients.append([[pos*3+1, (pos+d)*3+1], f12])
        
        
        for ei in xrange(number_epitopes):
            pos = np.random.random_integers(L/3-10)
            epi_strength = np.random.exponential(epitope_strength)
            if number_epitopes:
                    print 'epitope', pos*3, epi_strength
            epi, f1,f2,f12=add_epitope(epi_strength)
            single_locus_effects[(pos+epi[0])*3+1]+=f1
            single_locus_effects[(pos+epi[1])*3+1]+=f2
            multi_locus_coefficients.append([[(pos+epi[0])*3+1, (pos+epi[1])*3+1], f12])

        for mlc in multi_locus_coefficients:
            self.add_trait_coefficient(mlc[1], np.asarray(mlc[0], int), traitnumber)
        self._update_traits()
        self._update_fitness()

    def get_replication_additive(self):
        '''The additive part of the replication lansdscape.

        Returns:
           - coefficients: array of additive replication coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''
        return self.get_trait_additive(0)


    def set_replication_additive(self, coefficients):
        '''Set the additive replication coefficients

        Parameters:
           - coefficients: array of additive replication coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''

        self.set_trait_additive(coefficients, 0)


    def get_resistance_additive(self):
        '''The additive part of the resistance lansdscape.

        Returns:
           - coefficients: array of additive drug resistance coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''
        return self.get_trait_additive(1)


    def set_resistance_additive(self, coefficients):
        '''Set the additive drug resistance coefficients

        Parameters:
           - coefficients: array of additive drug resistance coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''

        self.set_trait_additive(coefficients, 1)



    def set_replication_landscape(self,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set the phenotypic landscape for the replication capacity of HIV.
        
        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.
        
        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        self.set_trait_landscape(traitnumber=0,
                            lethal_fraction=lethal_fraction,
                            deleterious_fraction=deleterious_fraction,
                            adaptive_fraction=adaptive_fraction,
                            effect_size_lethal=effect_size_lethal,
                            effect_size_deleterious=effect_size_deleterious,
                            effect_size_adaptive=effect_size_adaptive,
                            env_fraction=env_fraction,
                            effect_size_env=effect_size_env,
                            number_epitopes=number_epitopes,
                            epitope_strength=epitope_strength,
                            number_valleys=number_valleys,
                            valley_strength=valley_strength)


    def set_resistance_landscape(self,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set the phenotypic landscape for the drug resistance of HIV.
        
        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.
        
        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        self.set_trait_landscape(traitnumber=1,
                            lethal_fraction=lethal_fraction,
                            deleterious_fraction=deleterious_fraction,
                            adaptive_fraction=adaptive_fraction,
                            effect_size_lethal=effect_size_lethal,
                            effect_size_deleterious=effect_size_deleterious,
                            effect_size_adaptive=effect_size_adaptive,
                            env_fraction=env_fraction,
                            effect_size_env=effect_size_env,
                            number_epitopes=number_epitopes,
                            epitope_strength=epitope_strength,
                            number_valleys=number_valleys,
                            valley_strength=valley_strength)



hivpopulation.read_replication_coefficients = new_instancemethod(_FFPopSim.hivpopulation_read_replication_coefficients,None,hivpopulation)
hivpopulation.read_resistance_coefficients = new_instancemethod(_FFPopSim.hivpopulation_read_resistance_coefficients,None,hivpopulation)
hivpopulation.write_genotypes = new_instancemethod(_FFPopSim.hivpopulation_write_genotypes,None,hivpopulation)
hivpopulation.__str__ = new_instancemethod(_FFPopSim.hivpopulation___str__,None,hivpopulation)
hivpopulation.__repr__ = new_instancemethod(_FFPopSim.hivpopulation___repr__,None,hivpopulation)
hivpopulation_swigregister = _FFPopSim.hivpopulation_swigregister
hivpopulation_swigregister(hivpopulation)



